<html><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" /><title>Offloading NixOS builds to a faster machine</title><meta name="description" content="steenuil's blog" /><meta name="generator" content="generator.rkt" /><meta name="referrer" content="strict-origin" /><link rel="stylesheet" href="/assets/style.css" type="text/css" /><link rel="alternate" href="/rss.xml" type="application/rss+xml" title="RSS feed" /><link rel="alternate" href="/feed.xml" type="application/atom+xml" title="Atom feed" /><link rel="apple-touch-icon-precomposed" href="/assets/icon/favicon-152.png" /><meta name="og:type" content="website" /><meta name="og:title" content="Offloading NixOS builds to a faster machine" /><meta name="og:description" content="steenuil's blog" /><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@steinuil" /><meta name="twitter:creator" content="@steinuil" /><meta name="twitter:dnt" content="on" /></head><body id="blog-post-page"><div class="body-container"><header><nav><ul><li><a href="/molten-matter/">Molten Matter</a></li><li><a href="/">About</a></li><li><a href="/legal/">Legal</a></li></ul></nav></header><main><header><h1 class="post-title">Offloading NixOS builds to a faster machine</h1> <time datetime="2021-01-24">2021/01/24</time></header><div class="text"><p>I have a Raspberry Pi 3 sitting next to my router, from which I host a couple things to my local network. I installed NixOS on it and I love the experience: it completely removes the absolute nightmare that is configuring a Linux machine, and I find that incredibly liberating. But there&rsquo;s a catch: the Pi is slow and it doesn&rsquo;t have a lot of memory. Just evaluating the configuration with <code>nixos-rebuild</code> takes about a minute even when there haven&rsquo;t been any changes, and compiling anything substantial is usually a recipe for Death By Swap.</p><p>The other day I tried updating the main <a href="https://nixos.wiki/wiki/Nix_channels">channel</a> (the package repository) and upgrading my packages with <code>nixos-rebuild switch --upgrade</code> and found out that one of the packages I was using wasn&rsquo;t available on the main <a href="https://nixos.wiki/wiki/Binary_Cache">binary cache</a> at <code>cache.nixos.org</code> anymore, so it had to be built locally. The program in question is written in Rust and has a pretty sizeable dependency graph. I left it to build overnight. The morning after it was still stuck on building one of the sub-packages, and I couldn&rsquo;t even open a new ssh connection to the Pi.</p><p>There&rsquo;s a couple solutions to this:</p></div><ul><li>Build the program on another machine and add a new package that just fetches this binary and patches it</li><li>Setting up a binary cache on another machine</li><li>Setting up distributed builds</li></ul><div class="text"><p>The first one is an ugly hack (in Nix terms, at least) and would probably end up being more trouble than it&rsquo;s worth.</p><p>The second option, setting up another binary cache, is definitely better. The <a href="https://nixos.wiki/wiki/Binary_Cache">wiki page</a> does a good job of explaining how to set up the server, and on the client you just need to add a couple lines to your <code>configuration.nix</code> to enable it:</p></div><pre class="brush: nix"><code>  nix.binaryCaches = [ "http://&lt;server url&gt;" ];
  nix.binaryCachePublicKeys = [ "&lt;the cache's public key&gt;" ];</code></pre><div class="text"><p>The downside is that you have to know beforehand which packages you need to build, and not being very well-versed in Nix I couldn&rsquo;t figure out how to build the specific versions I needed.</p><p>So we&rsquo;re left with the third option, distributed builds. The <a href="https://nixos.wiki/wiki/Distributed_build">wiki page</a> opens with this paragraph:</p></div><blockquote class="text"><p>Sometimes you want to use a faster machine for building a nix derivation you want to use on a slower one. If you have ssh access to a machine where Nix (not necessarily NixOS) is installed, then you can offload building to this machine.</p></blockquote><div class="text"><p>Which seems to be exactly what I&rsquo;m looking for.</p><p>The wiki mentions a couple options to add in <code>configuration.nix</code> to enable offloading builds to the client. I used these on the Pi:</p></div><pre class="brush: nix"><code>  nix.distributedBuilds = true;
  nix.buildMachines = [
    {
      hostName = "builder";
      systems = [ "x86_64-linux" "aarch64-linux" ];
      maxJobs = 4;
      speedFactor = 2;
      supportedFeatures = [ "nixos-test" "benchmark" "big-parallel" "kvm" ];
    }
  ];
  programs.ssh.extraConfig = ''
Host builder
  HostName &lt;url of the host&gt;
  Port 2222
  User builder
  IdentitiesOnly yes
  IdentityFile /root/.ssh/id_builder
  '';</code></pre><div class="text"><p>I created the key in <code>/root/.ssh/id_builder</code> using the options recommended in <a href="https://security.stackexchange.com/a/144044">this Stack Exchange answer</a> (not that it matters since it&rsquo;s all on my local network):</p></div><pre><code># ssh-keygen -t ed25519 -a 100 -f /root/.ssh/id_builder</code></pre><div class="text"><p>For the host machine I had to go with emulation, since I don&rsquo;t have another ARM64 machine lying around. My beefy desktop runs Windows so I created a VirtualBox machine with 4 cores, 8GB of memory, and a couple GB of hard drive space to store the build results. Setting up emulation was incredibly easy after finding <a href="https://nixos.wiki/wiki/NixOS_on_ARM#Compiling_through_QEMU">the NixOS on ARM wiki page</a>, all it takes is one line in the VM&rsquo;s <code>configuration.nix</code>:</p></div><pre class="brush: nix"><code>  boot.binfmt.emulatedSystems = [ "aarch64-linux" ];</code></pre><div class="text"><p>Then I had to activate OpenSSH with <code>services.openssh.enable = true;</code>, add the Pi&rsquo;s public key to <code>/home/builder/.ssh/authorized_keys</code>, forward the SSH port on the VM to 2222, and open that port in the Windows firewall.</p><p>To test that it&rsquo;s working you can try building a package on the client with the <code>max-jobs</code> option set to 0.</p></div><pre><code>nix-build -j0 --expr 'with import &lt;nixpkgs&gt; {}; callPackage ./default.nix {}'</code></pre><div class="text"><p>I&rsquo;m really surprised by how simple all of that was. Setting up a VM that automatically builds packages for another machine while emulating another architecture sounds like a nightmare, but with NixOS it&rsquo;s a couple lines of configuration.</p><p>And in case you&rsquo;re wondering, yes, it worked beautifully, and even though the emulation slows things down quite a bit it&rsquo;s still much faster than building things directly on the Pi.</p></div></main><footer>made with <a href="https://racket-lang.org/">racket</a> :: <a href="/rss.xml">rss</a> :: <a href="/feed.xml">atom</a></footer></div></body></html>
<html><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" /><title>Reading Ur/Web signatures, part 1</title><meta name="description" content="steenuil's blog" /><meta name="generator" content="generator.rkt" /><meta name="referrer" content="strict-origin" /><link rel="stylesheet" href="/assets/style.css" type="text/css" /><link rel="alternate" href="/rss.xml" type="application/rss+xml" title="RSS feed" /><link rel="alternate" href="/feed.xml" type="application/atom+xml" title="Atom feed" /><meta name="og:type" content="website" /><meta name="twitter:site" content="@steinuil" /><meta name="twitter:creator" content="@steinuil" /><meta name="og:description" content="steenuil's blog" /><meta name="og:title" content="Reading Ur/Web signatures, part 1" /><meta name="twitter:card" content="summary" /></head><body id="blog-post-page"><div class="body-container"><header><nav><ul><li><a href="/molten-matter/">Molten Matter</a></li><li><a href="/">About</a></li><li><a href="/legal/">Legal</a></li></ul></nav></header><main><header><h1 class="post-title">Reading Ur/Web signatures, part 1</h1> <time datetime="2019-01-07">2019/01/07</time></header><div class="text"><p>So you stumbled upon Ur/Web and you rather like what it&rsquo;s about, but after trudging through the tutorials and the examples in the few blog posts you&rsquo;ve seen around you can&rsquo;t seem to find your own footing. The compiler errors are long and life is short and you&rsquo;re about to throw your computer out the window.</p><p><a href="/molten-matter/urweb/">I understand.</a></p><p>In this post, I&rsquo;ll walk you through the signatures of a few functions from the standard library, hopefully providing you with enough context to make it through the rest on your own. You might want to grab <a href="https://github.com/urweb/urweb/tree/master/lib/ur">a copy</a> or search for the one on your hard drive so you can follow along.</p><p>I&rsquo;m going to be frank: given the current state of the ecosystem and of the documentation, you have close to no chance of learning Ur/Web if you don&rsquo;t already know some OCaml/ReasonML or another language in the ML family, so if you don&rsquo;t you might want to get well acquainted with one first. <a href="https://elm-lang.org/">Elm</a> is a good starting point.</p><p>Open up <code>string.urs</code> and have a look around. I&rsquo;m going to assume you can read these signatures:</p></div><pre class="brush: urs"><code>type t = string

val length : t -&gt; int

val append : t -&gt; t -&gt; t

val all : (char -&gt; bool) -&gt; string -&gt; bool</code></pre><div class="text"><p>Still here? Good, let&rsquo;s introduce some new syntax.</p></div><pre class="brush: urs"><code>val index : string -&gt; char -&gt; option int</code></pre><div class="text"><p>If you come from OCaml or SML you might notice that the argument of the type constructor <code>option</code> is to the right of the constructor, as in normal function application. This unification of function and type constructor application is not just a matter of syntax like in <a href="https://reasonml.github.io/docs/en/comparison-to-ocaml#type-parameters">ReasonML</a>; put this in the back of your mind for the moment, we&rsquo;ll come back to it later.</p></div><pre class="brush: urs"><code>val substring : string -&gt; {Start : int, Len : int} -&gt; string</code></pre><div class="text"><p>Much like SML, Ur/Web makes up for the lack of labeled arguments by using anonymous records as function arguments. Also, record field names must start with a capital letter like the members of a variant.</p></div><header class="heading" id="generics">Generics</header><div class="text"><p>Let&rsquo;s kick things up a notch. Open up <code>list.urs</code> and you&rsquo;ll be greeted by something like this:</p></div><pre class="brush: urs"><code>val rev : a ::: Type -&gt; list a -&gt; list a</code></pre><div class="text"><p>As you might have guessed, <code>List.rev</code> is a function that takes a list of elements and returns another list with the elements of the first, in reverse order. <code>rev</code> can reverse lists that contain any element, so we say that it is <em>polymorphic</em>.</p><p><code>a</code> is the type of the values contained in the input and output list. The argument <code>a ::: Type</code> is just a way of saying that we don&rsquo;t know what type <code>a</code> will be when we declare the function; it&rsquo;s up to the caller to bind it to a valid type. The triple colon (<code>:::</code>) means that this type parameter is implicit, so the compiler will take care of inserting the correct type when calling it.</p><p>OCaml and most other languages don&rsquo;t require you to explicitly declare these type parameter, but <a href="https://blog.janestreet.com/ensuring-that-a-function-is-polymorphic-in-ocaml-3-12/">sometimes it is useful</a> to ensure the well-typedness of a polymorphic function.</p><p>Quoting from the <a href="http://www.impredicative.com/ur/tutorial/intro.html">tutorial</a>:</p></div><blockquote class="text"><p>Unlike in ML and Haskell, polymorphic functions in Ur/Web often require full type annotations. That is because more advanced features make Ur type inference undecidable.</p></blockquote><div class="text"><p>Let&rsquo;s pull up the implementation for a moment (found in <code>list.ur</code>):</p></div><pre class="brush: ur"><code>fun rev [a] (ls : list a) = ...</code></pre><div class="text"><p>The <code>a</code> in square brackets here corresponds to <code>a ::: Type</code> in the signature above. We could also write it like <code>[a ::: Type]</code> if we wanted to be more explicit.</p><p>Now let&rsquo;s look at <code>List.mp</code>. (Which is just the <code>List.map</code> function, but it can&rsquo;t be called <code>map</code> because <code>map</code> is a keyword in Ur/Web. More on that later.)</p></div><pre class="brush: urs"><code>val mp : a ::: Type -&gt; b ::: Type -&gt; (a -&gt; b) -&gt; list a -&gt; list b</code></pre><div class="text"><p><code>mp</code> has two polymorphic type parameters, so they are both made explicit in the signature.</p><p>Interestingly, we can write a function so that the type parameter has to be passed <em>explicitly</em> by replacing <code>:::</code> with a double colon (<code>::</code>):</p></div><pre class="brush: ur"><code>(* id.urs *)
val id : a :: Type -&gt; a -&gt; a

(* id.ur *)
fun id [a :: Type] (x : a) = x

val x = id [int] 451</code></pre><div class="text"><p><code>:::</code> indicates a type parameter that may be inferred by the compiler, while <code>::</code> indicates one that has to be passed explicitly. The compiler will be able to infer a type parameter by itself most of the time, but in some cases which we&rsquo;ll see later you&rsquo;ll have to be explicit and use the double colon.</p></div><header class="heading" id="basics-of-type-constructors">Basics of type constructors</header><div class="text"><p>At this point I should introduce Ur/Web&rsquo;s type constructors, because they&rsquo;re a lot more powerful than those in most other languages. Open up <code>json.ur</code> (not <code>json.urs</code>) and the first thing you&rsquo;ll see will be this:</p></div><pre class="brush: ur"><code>con json a = {ToJson : a -&gt; string,
              FromJson : string -&gt; a * string}</code></pre><div class="text"><p>While the <code>con</code> keyword might throw you off, you might recognize this as a simple type declaration. Ur/Web actually makes a distinction between simple aliases, like the one we encountered at the top of <code>string.urs</code>, and type constructors, which take one (or more!) arguments, and have to be declared with the keyword <code>con</code>.</p><p>The <code>json</code> type constructor is simply a record with an encoder function which takes an <code>a</code> and returns a JSON string, and a decoder function which takes a JSON string and returns an <code>a</code> and the remaining JSON string.</p><p>Remember that thing earlier about unifying function application and type constructor application syntax? The two are actually very closely related: just as normal functions are functions from values to values, type constructors can be thought of as <strong>type-level functions from types to types</strong>, and the purpose of this unification is just to make the similarity more apparent.</p><p>This insight might not net you much in OCaml or SML because type constructors have a lot of limitations compared to functions: they can&rsquo;t be curried, and you can perform very few operations inside them.</p><p>Ur/Web&rsquo;s type constructors are much more interesting. The <code>json</code> declaration above is actually syntactic sugar for a type-level function:</p></div><pre class="brush: ur"><code>con json = fn (a :: Type) =&gt;
  {ToJson : a -&gt; string,
   FromJson : string -&gt; a * string}</code></pre><div class="text"><p>We can define a <strong>curried</strong> constructor that takes two types and returns the type of a 2-tuple:</p></div><pre class="brush: ur"><code>con pair a b = a * b

con intAnd :: Type -&gt; Type = pair int

val p : intAnd string = (451, "what a shame")</code></pre><div class="text"><p>We can also perform various useful operations on record types, as we&rsquo;ll see later.</p></div><header class="heading" id="type-classes">Type classes</header><div class="text"><p>Ur/Web&rsquo;s <code>=</code> (equals) operator works just like you&rsquo;d expect it to for types provived by the standard library: <code>1 = 1</code>, <code>"line" = "line"</code>, and <code>Some "just" = Some "just"</code>. So is it implemented like in <a href="https://blog.janestreet.com/the-perils-of-polymorphic-compare/">OCaml</a>, using a &ldquo;magic&rdquo; internal function that structurally compares record fields and variant members? Not quite.</p><p>If we try to compare two records, we&rsquo;ll get a surprisingly helpful error message:</p></div><pre class="brush: ur"><code>(* test.ur *)
val ok = { A = 1 } = { A = 1 }

(* test.ur:1:5: (to 1:26) Can't resolve type class instance
   Class constraint: eq {A : int} *)</code></pre><div class="text"><p>Let&rsquo;s take a look into <code>basis.urs</code>. At line 26, you&rsquo;ll see these declarations:</p></div><pre class="brush: urs"><code>class eq
val eq : t ::: Type -&gt; eq t -&gt; t -&gt; t -&gt; bool</code></pre><div class="text"><p>The signature of the <code>eq</code> function looks familiar enough. We still don&rsquo;t know what <code>class eq</code> means, but by the way it&rsquo;s used in the function we can infer that it&rsquo;s a constructor that takes one argument.</p><p>In fact, <code>eq</code> is just an <a href="https://caml.inria.fr/pub/docs/manual-ocaml/moduleexamples.html#sec20">abstract type</a>, i.e. a type whose implementation isn&rsquo;t specified in its signature so that only the underlying module can access it. If you don&rsquo;t know what that is, you can think of it as an opaque pointer in C.</p><p>In this case we can&rsquo;t look at its actual implementation because <code>Basis</code> is implemented directly in C, but it would look somewhat like this:</p></div><pre class="brush: ur"><code>con eq t = t -&gt; t -&gt; bool</code></pre><div class="text"><p>So now we should have all the pieces to understand the <code>eq</code> function above. Or do we?</p><p>If you were to define your own <code>eq</code> constructor and your own <code>eq</code> function, you&rsquo;d always have to pass a function of type <code>eq t</code> as first argument. (This kind of function can also be called <strong>witness</strong>.)</p></div><pre class="brush: ur"><code>con eq' t = t -&gt; t -&gt; bool

fun eq' [t] (cmp : eq' t) (a : t) (b : t) =
  cmp a b

fun eq'_bool (a : bool) (b : bool) =
  case (a, b) of
  | (True, True) =&gt; True
  | (False, False) =&gt; True
  | _ =&gt; False

val test = eq' eq'_bool True False</code></pre><div class="text"><p>But if we were to do the same with eq, we would get a compiler error.</p><p>Turns out that the <code>eq</code> function is just the desugared name of the <code>=</code> operator, and as we&rsquo;ve seen above, we can use it transparently without having to worry about the witness function. This is where the <code>class</code> keyword comes into play.</p><p>When we mark <code>eq</code> with the <code>class</code> keyword in a signature file, the compiler will automatically search for a fitting implementation of <code>eq t</code> every time we call <code>=</code> with a given <code>t</code>.</p><p>The <code>option</code> constructor also defines an <code>eq</code> witness in the <code>Option</code> module. This is its signature:</p></div><pre class="brush: urs"><code>val eq : a ::: Type -&gt; eq a -&gt; eq (option a)</code></pre><div class="text"><p>This should be straightforward by now. <code>Option.eq</code> implicitly takes a witness <code>eq a</code> and maps it to the value stored inside the option, if any. Let&rsquo;s take a look at its implementation.</p></div><pre class="brush: ur"><code>fun eq [a] (_ : eq a) =
    mkEq (fn x y =&gt;
             case (x, y) of
                 (None, None) =&gt; True
               | (Some x, Some y) =&gt; x = y
               | _ =&gt; False)</code></pre><div class="text"><p>The wildcard corresponds to the witness argument, even though the function doesn&rsquo;t use it directly. In a way, the witness argument is just there to <strong>constrain</strong> the types we can call <code>Option.eq</code> with to those for which there exists an implementation of <code>eq</code>.</p><p>Now the error message should make sense: the compiler is telling us that this invocation of <code>=</code> has a constraint of type <code>eq {A : int}</code> on its arguments, so we need to implement a witness of <code>eq</code> for <code>{A : int}</code>. We&rsquo;ll have to use the <code>mkEq</code> function to do this.</p></div><pre class="brush: ur"><code>val eq_a_int = mkEq
  (fn (a : {A : int}) (b : {B : int}) =&gt;
    a.A = b.A)

(* this will compile now *)
val ok = { A = 1 } = { A = 1 }</code></pre><header class="heading" id="to-be-continued">To be continued&hellip;</header><div class="text"><p>This post is getting pretty long, so I&rsquo;ll wrap it up here for this week. If you already knew most of the things I covered here, don&rsquo;t worry, the next one is gonna cover some of the most foreign parts of the type system.</p><p>Watch this space for part 2! (I promise I&rsquo;ll implement an RSS feed soon.) In the meantime, you might want to brush up on <a href="http://blog.haberkucharsky.com/technology/2015/07/21/more-monads-in-ocaml.html">monads</a>, or take a look at the more dense <a href="http://impredicative.com/ur/tutorial/">official tutorial</a>.</p></div></main><footer>made with <a href="https://racket-lang.org/">racket</a> :: <a href="/rss.xml">rss</a> :: <a href="/feed.xml">atom</a></footer></div></body></html>
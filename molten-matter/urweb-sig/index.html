<html><head><title>How to read Ur/Web signatures, part 1</title><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" /><link rel="stylesheet" href="/assets/style.css" type="text/css" /></head><body id="blog-post-page"><div class="body-container"><header><nav><ul><li><a href="/molten-matter/">Molten Matter</a></li><li><a href="/">About</a></li><li><a href="/legal/">Legal</a></li></ul></nav></header><main><header><div class="post-title">How to read Ur/Web signatures, part 1</div> <time datetime="2019-01-05">2019/01/05</time></header><div class="text"><p>So you&rsquo;ve read <a href="/molten-matter/urweb/">my post on Ur/Web</a> or you&rsquo;ve stumbled across the language</p><p>In this post, I&rsquo;ll walk you through the signatures of a few functions from the standard library, hopefully providing some help in understanding the most unreadable ones.</p><p>I&rsquo;ll assume you already know how to read basic type signatures in OCaml/ReasonML or SML (which you should be familiar with if you actually want to learn Ur/Web).</p><p>You might want to grab a copy of <a href="https://github.com/urweb/urweb/tree/master/lib/ur">the standard library</a> or search for the one on your hard drive so you can follow along.</p><p>Open up <code>string.urs</code> and have a look around. You should be able to tell what these functions do:</p></div><pre class="brush: urs"><code>type t = string

val length : t -&gt; int

val append : t -&gt; t -&gt; t

val all : (char -&gt; bool) -&gt; string -&gt; bool</code></pre><div class="text"><p>Still here? Good, let&rsquo;s introduce some new syntax.</p></div><pre class="brush: urs"><code>val index : string -&gt; char -&gt; option int</code></pre><div class="text"><p>If you come from OCaml or SML you might notice that the argument of the type constructor <code>option</code> is to the right of the constructor, as in normal function application. This unification of function and type constructor application is not just a matter of syntax like in <a href="https://reasonml.github.io/docs/en/comparison-to-ocaml#type-parameters">ReasonML</a>; put it in the back of your mind for the moment, we&rsquo;ll come back to it later.</p></div><pre class="brush: urs"><code>val substring : string -&gt; {Start : int, Len : int} -&gt; string</code></pre><div class="text"><p>Much like SML, Ur/Web makes up for the lack of labeled arguments by using anonymous records as function arguments. Also, record field names must start with a capital letter like the members of a variant.</p></div><header class="heading" id="generics">Generics</header><div class="text"><p>Let&rsquo;s kick things up a notch. Open up <code>list.urs</code> and you&rsquo;ll be greeted with something like this:</p></div><pre class="brush: urs"><code>val rev : a ::: Type -&gt; list a -&gt; list a</code></pre><div class="text"><p>I think looking at the implementation might make it a bit easier on the eyes, so let&rsquo;s pull it up for a moment before going back to its signature.</p></div><pre class="brush: ur"><code>fun rev [a] (ls : list a) = ...</code></pre><div class="text"><p>The <code>a</code> in square brackets here corresponds to <code>a ::: Type</code> in the signature above. We could also write it like <code>[a ::: Type]</code> if we wanted to be more explicit.</p><p>As you might have guessed, <code>a</code> is an explicit type parameter that ensures <code>rev</code> is polymorphic. OCaml also has <a href="https://blog.janestreet.com/ensuring-that-a-function-is-polymorphic-in-ocaml-3-12/">a similar syntax</a> for ensuring the well-typedness of a polymorphic function, but while expliciting the polymorphic type parameters might be optional in OCaml, it is not in Ur/Web.</p><p>Quoting from the <a href="http://www.impredicative.com/ur/tutorial/intro.html">tutorial</a>:</p></div><blockquote><p>Unlike in ML and Haskell, polymorphic functions in Ur/Web often require full type annotations. That is because more advanced features make Ur type inference undecidable.</p></blockquote><div class="text"><p>Let&rsquo;s look at <code>List.mp</code> (which is just the <code>List.map</code> function, but it can&rsquo;t be called <code>map</code> because <code>map</code> is a keyword in Ur/Web).</p></div><pre class="brush: urs"><code>val mp : a ::: Type -&gt; b ::: Type -&gt; (a -&gt; b) -&gt; list a -&gt; list b</code></pre><div class="text"><p><code>mp</code> has two polymorphic type parameters, so they are both made explicit in the signature.</p><p>Interestingly, we can write a function so that the type parameter has to be passed <strong>explicitly</strong> by replacing the triple colon (<code>:::</code>) with a double colon (<code>::</code>):</p></div><pre class="brush: ur"><code>(* id.urs *)
val id : a :: Type -&gt; a -&gt; a

(* id.ur *)
fun id [a :: Type] (x : a) = x

val x = id [int] 451</code></pre><div class="text"><p><code>:::</code> indicates a type parameter that may be inferred by the compiler, while <code>::</code> indicates one that has to be passed explicitly. The compiler will be able to infer a type parameter by itself most of the time, but in some cases which we&rsquo;ll see later you&rsquo;ll have to be explicit and use the double colon.</p></div><header class="heading" id="basics-of-type-constructors">Basics of type constructors</header><div class="text"><p>At this point I should introduce type constructors, because they can do a lot more than those in other languages. Open up <code>json.ur</code> (not <code>json.urs</code>) and the first thing you&rsquo;ll see will be this:</p></div><pre class="brush: ur"><code>con json a = {ToJson : a -&gt; string,
              FromJson : string -&gt; a * string}</code></pre><div class="text"><p>While the <code>con</code> keyword might throw you off, you might recognize this as a simple type declaration. Ur/Web actually makes a distinction between simple aliases, like the one we encountered at the top of <code>string.urs</code>, and type constructors, which take one (or more!) arguments, and have to be declared with the keyword <code>con</code>.</p><p>The <code>json</code> type constructor is simply a record with an encoder function which takes an <code>a</code> and returns a JSON string, and a decoder function which takes a JSON string and returns an <code>a</code> and the remaining JSON string.</p><p>Remember what I said earlier about unifying function application and type constructor application? As it turns out, <strong>type constructors are actually type-level functions</strong>, and the purpose of this unification is just to make this similarity more apparent.</p><p>This insight will not net you much in OCaml or SML because type constructors have a lot of limitations compared to functions: they can&rsquo;t be curried, and you can perform very few operations on them.</p><p>Ur/Web&rsquo;s type constructors don&rsquo;t have these limitations. In fact, the <code>json</code> declaration above is actually syntactic sugar for a type-level function:</p></div><pre class="brush: ur"><code>con json = fn (a :: Type) =&gt;
  {ToJson : a -&gt; string,
   FromJson : string -&gt; a * string}</code></pre><div class="text"><p>We can define a <strong>curried</strong> constructor that takes two types and returns the type of a 2-tuple:</p></div><pre class="brush: ur"><code>con pair a b = a * b

con intAnd :: Type -&gt; Type = pair int

val p : intAnd string = (451, "what a shame")</code></pre><div class="text"><p>We can also perform various useful operations on record types, as we&rsquo;ll see later.</p></div><header class="heading" id="type-classes">Type classes</header><div class="text"><p>Ur/Web&rsquo;s <code>=</code> (equals) operator works just like you&rsquo;d expect it to for types provived by the standard library: <code>1 = 1</code>, <code>"line" = "line"</code>, and <code>Some "just" = Some "just"</code>. So is it implemented like in <a href="https://blog.janestreet.com/the-perils-of-polymorphic-compare/">OCaml</a>, using a &ldquo;magic&rdquo; internal function that structurally compares record fields and variant members? Not quite.</p><p>If we try to compare two records, we&rsquo;ll get a surprisingly helpful error message:</p></div><pre class="brush: ur"><code>(* test.ur *)
val ok = { A = 1 } = { A = 1 }

(* test.ur:1:5: (to 1:26) Can't resolve type class instance
   Class constraint: eq {A : int} *)</code></pre><div class="text"><p>Let&rsquo;s take a look into <code>basis.urs</code>. At line 26, you&rsquo;ll see these declarations:</p></div><pre class="brush: urs"><code>class eq
val eq : t ::: Type -&gt; eq t -&gt; t -&gt; t -&gt; bool</code></pre><div class="text"><p>The signature of the <code>eq</code> function looks familiar enough. We still don&rsquo;t know what <code>class eq</code> means, but by the way it&rsquo;s used in the function we can infer that it&rsquo;s a constructor that takes one argument.</p><p>In fact, <code>eq</code> is just an <a href="https://caml.inria.fr/pub/docs/manual-ocaml/moduleexamples.html#sec20">abstract type</a>, i.e. a type whose implementation isn&rsquo;t specified in its signature so that only the underlying module can access it. If you don&rsquo;t know what that is, you can think of it as an opaque pointer in C.</p><p>In this case we can&rsquo;t look at its implementation because <code>Basis</code> is implemented in C, but it would look somewhat like this:</p></div><pre class="brush: ur"><code>con eq t = t -&gt; t -&gt; bool</code></pre><div class="text"><p>So now we should have all the pieces to understand the <code>eq</code> function above. Or do we?</p><p>If you were to define your own <code>eq</code> constructor and your own <code>eq</code> function, you&rsquo;d always have to pass a function of type <code>eq t</code> as first argument (also called <em>witness</em>):</p></div><pre class="brush: ur"><code>con eq' t = t -&gt; t -&gt; bool

fun eq' [t] (cmp : eq' t) (a : t) (b : t) =
  cmp a b

fun eq'_bool (a : bool) (b : bool) =
  case (a, b) of
  | (True, True) =&gt; True
  | (False, False) =&gt; True
  | _ =&gt; False

val test = eq' eq'_bool True False</code></pre><div class="text"><p>Turns out that the <code>eq</code> function is just the desugared name of the <code>=</code> operator, and we used it above without having to worry about the witness function. This is where the <code>class</code> keyword comes into play.</p><p>When we mark <code>eq</code> with the <code>class</code> keyword in a signature file, the compiler will automatically search for a fitting implementation of <code>eq t</code> every time we call <code>=</code> with a given <code>t</code>.</p><p>The <code>option</code> constructor also defines an <code>eq</code> witness in the <code>Option</code> module. This is its signature:</p></div><pre class="brush: urs"><code>val eq : a ::: Type -&gt; eq a -&gt; eq (option a)</code></pre><div class="text"><p>This should be straightforward by now. But how is it implemented?</p></div><pre class="brush: ur"><code>fun eq [a] (_ : eq a) = ...</code></pre><div class="text"><p>Even though we might not actually use the witness function, Ur/Web still requires us to specify it in the implementation, hence the wildcard. This argument can also be called a <strong>constraint</strong> on <code>a</code>.</p><p>Now the error message should make sense: the compiler is telling us that the <code>=</code> function has a constraint of type <code>eq {A : int}</code> on its arguments, so we need to implement <code>eq</code> for <code>{A : int}</code>. Since <code>eq</code> is an opaque type, we need to use the <code>mkEq</code> function to do this.</p></div><pre class="brush: ur"><code>val eq_a_int = mkEq
  (fn (a : {A : int}) (b : {B : int}) =&gt;
    a.A = b.A)

val ok = { A = 1 } = { A = 1 }</code></pre></main><footer>this web sight made with <a href="https://racket-lang.org/">Racket</a>.</footer></div></body></html>
<html><head><title>I survived Ur/Web</title><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" /><link rel="stylesheet" href="/assets/style.css" type="text/css" /></head><body id="blog-post-page"><div class="body-container"><header><nav><ul><li><a href="/molten-matter/">Molten Matter</a></li><li><a href="/">About</a></li><li><a href="/legal/">Legal</a></li></ul></nav></header><main><header>I survived Ur/Web</header><div class="text"><p>I don&rsquo;t remember when it was that I first tried Ur/Web, but I&rsquo;m sure I didn&rsquo;t last long with it. As soon as I strayed a bit from the examples provided on the website (seemingly the only documentation available), I would hit a brick wall, in the form of unreadable compiler errors. I got so frustrated that I deleted all the files I was working on and the compiler with them, and I didn&rsquo;t touch the language for a while.</p><p>I&rsquo;d try again after a few months, once again lured in by the ludicrous promises listed on the front page of the website: no more complex ORMs, no more crappy templating languages, no more brittle internal APIs, and all of this packaged up in a neat ML-like language with a solid and powerful type system that compiles down to very efficient C code. It was too good to be true, and I wanted into it. Soon enough I&rsquo;d hit another brick wall and the cycle would repeat itself once again, until I got to the point where I was confident enough in the language that I could write it for a few hours without getting stuck too much.</p><p>As it turns out, my frustration with it is one of the language&rsquo;s many features. In the age of languages like Elm and Go, which jeopardize sophistication to appeal to the newcomers, Ur/Web takes Haskell&rsquo;s motto of avoiding success at all costs and runs with it. <a href="http://www.impredicative.com/pipermail/ur/2010-December/000329.html">In the words of the language&rsquo;s creator</a>:</p></div><blockquote><p>I also want to emphasize that I&rsquo;m not trying to maximize adoption of Ur/Web. Rather, I&rsquo;m trying to maximize the effectiveness of people who do choose to use it. This means that I&rsquo;m completely happy if basic features of Ur/Web mean that 90% of programmers will never be able to use it.</p></blockquote><div class="text"><p>Seen from this perspective, everything starts falling into place. The homepage straight from the late 90s, the few examples and the TeX-formatted PDF manual, the lack of any sort of documentation to the standard library that doesn&rsquo;t involve digging through the scantly commented signature files. <strong>It&rsquo;s all intended.</strong></p><p>Jokes aside, while I do find the approach to language design admirable, I think the ecosystem could use a lot of improvement; at the very least some more comments in the stdlib signature files and possibly some way to generate an HTML page out of them, in the style of <code>ocamldoc</code>. I&rsquo;ve spent enough time trying to differentiate <code>queryL</code> and <code>queryL1</code> that I&rsquo;ve developed a feel for it, but I&rsquo;d much rather have a thorough explaination of why they&rsquo;re named like that.</p><p>The compiler also outputs errors which range from completely unhelpful parsing errors to dozens and dozens of desugared XML and SQL statements which rival C++ template error messages in succintness and readability. As with the standard library functions, the error messages are there to give you a feel for what the compiler wants to see rather than to provide a useful explaination of what happened.</p></div><header id="the-good-parts">The good parts</header><div class="text"><p>I&rsquo;ve only bashed the language up to now, so it&rsquo;s about time that I start mentioning its good parts. Ur/Web is amazing! Part of the reason why I&rsquo;m writing this is in the hopes of getting even one other person interested in the project, because I think it deserves more users.</p><p>It&rsquo;s a long and winding road to get there, but Ur/Web <em>does</em> deliver on its promises of speeding up application development. Once you start working with the compiler rather than against it, you&rsquo;ll find that you only have to worry about the parts of your application that matter rather than getting entangled in busywork. The compiler will not only check for mismatches in the types of every function and value in the program like in a normal statically typed language, but it will also check them against the database tables, cookies, form fields and any other kind of client-server interaction; your program simply won&rsquo;t compile if you query a column that doesn&rsquo;t exist.</p><p>Defining tables, queries, cookies and RPC becomes pretty much effortless, and you can achieve a much higher level of &ldquo;separation of concerns&rdquo; through thoughtful use of the signature files. At first I tried going for a MVC-like approach by putting all my tables and queries in a module and all pages in another, but after a while I found that it makes more sense to define tables and cookies right in the modules that need them, so as not to needlessly expose them to modules that don&rsquo;t. Database tables and cookies in Ur/Web are somewhat like normal types, so you can keep them as an implementation detail of a module or expose them as needed.</p><p>Ur/Web also compiles the client-side portions of your code to Javascript, so you can write client code directly <em>in the page handler</em> and run the same functions both on the server and the client (as long as they don&rsquo;t use any server- or client-specific features). Reactive page generation <em>Ã  la React</em> is also supported through the <code>&lt;dyn/&gt;</code> tag, which lets you subscribe to a <code>source</code> (basically a mutable cell, similar to <code>ref</code> in OCaml) and automatically reacts when the source changes. You can also push data asynchronously to a client with <code>channel</code> and call functions that need server features without reloading the page with <code>rpc</code> (which unfortunately doesn&rsquo;t support file inputs, but I&rsquo;m working on an AJAX library that will let you do that).</p><p>The language works with a transactional model which marks every function that will have a different output even with the same inputs (e.g. a random number generator or a database query) with the type <code>transaction</code>, and undoes any changes that might have been made in case of an error. I had a bit of trouble understanding the model, mostly because <code>transaction</code> is a monad and I wasn&rsquo;t acquainted with the concept when I first tried the language, but after a while it became useful and natural to wall off the effectful functions from the rest of the code.</p></div><header id="the-future">The future?</header><div class="text"><p>Ur/Web is far from perfect; even with a better ecosystem, documentation and compiler messages, there&rsquo;s lots of things that annoy me (the &ldquo;end&rdquo; keyword in <code>let .. in .. end</code> blocks, the lack of a buffer type to make string manipulation less painful for the allocator, the lack of support for interacting with data types more complex than strings and integers in C bindings, &hellip;), but it still feels like working with a language from the future. A future where frameworks are actually compilers aware of the application domain, and will check non-trivial properties of a program for correctness.</p><p>That future, I think, is (or was) the end goal of the language&rsquo;s author, Adam Chlipala. He seems to have envisioned Ur as a language that allows syntactic and compiler extensions to fit any sort of application domain in a similar manner. He looks more interested in formal methods these days (though he&rsquo;s still actively developing Ur/Web) so I doubt this will ever come to fruition, but it might be a goal worth pursuing. Eduardo Julian, the author of the <a href="https://github.com/LuxLang/lux">Lux programming language</a>, gave a <a href="https://www.youtube.com/watch?v=T-BZvBWiamU">talk at StrangeLoop</a> last year where he talked with the fervor of a madman about a similar dream of letting users of his language implement domain-specific optimizations, core features and compilation targets without having to change the language itself. <a href="https://racket-lang.org/">Racket</a>&rsquo;s goal is to be both a general-purpose language and a language platform, with which users can implement their own domain-specific syntax and let it interact with normal Racket code or other domain-specific languages. There&rsquo;s probably other projects with similar goals that I don&rsquo;t know of, so perhaps we&rsquo;ll see more of this in the future.</p><p>Getting back to Ur/Web, if you like functional languages, hate the current state of web development, can bear with the lack of documentation and StackOverflow support, and already know a bit of Haskell/OCaml/SML, I recommend you try it. It takes a while for it to click, but when it does it&rsquo;s a wonderful experience, and you&rsquo;ll certainly learn something about types, MLs or even web development in the process.</p><p>For my part, I&rsquo;ll try to contribute some documentation to the project to make it a bit easier to get into the language.</p></div><header id="further-reading">Further reading:</header><ul><li><a href="http://blog.ezyang.com/2012/07/polymorphic-variants-in-urweb/">Polymorphic variants in Ur/Web</a></li></ul></main><footer>this web sight made with <a href="https://racket-lang.org/">Racket</a>.</footer></div></body></html>
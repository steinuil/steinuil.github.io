<html><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" /><title>Continuations, Promises, and call/cc</title><meta name="description" content="steenuil's blog" /><meta name="generator" content="generator.rkt" /><meta name="referrer" content="strict-origin" /><link rel="stylesheet" href="/assets/style.css" type="text/css" /><link rel="alternate" href="/rss.xml" type="application/rss+xml" title="RSS feed" /><link rel="alternate" href="/feed.xml" type="application/atom+xml" title="Atom feed" /><link rel="apple-touch-icon-precomposed" href="/assets/icon/favicon-152.png" /><meta name="og:type" content="website" /><meta name="og:title" content="Continuations, Promises, and call/cc" /><meta name="og:description" content="steenuil's blog" /><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@steinuil" /><meta name="twitter:creator" content="@steinuil" /><meta name="twitter:dnt" content="on" /></head><body id="blog-post-page"><div class="body-container"><header><nav><ul><li><a href="/molten-matter/">Molten Matter</a></li><li><a href="/">About</a></li><li><a href="/legal/">Legal</a></li></ul></nav></header><main><header><h1 class="post-title">Continuations, Promises, and call/cc</h1> <time datetime="2017-10-27">2017/10/27</time></header><div class="text"><p>Say you&rsquo;re in the kitchen in front of the refrigerator, thinking about continuations. You make yourself a sandwich right there and stick it on your desk. Then you sit on your armchair and open a browser window to search for their definition. You get a series of abstract explainations, and some examples involving fridges and sandwiches, which leave you more puzzled than when you began. You invoke the sandwich on your desk, and you find yourself wondering if the topic is even worth going through all this trouble to learn about.</p></div><h2 class="heading" id="promises">Promises</h2><div class="text"><p>Javascript has a concurrency model which can be somewhat daunting at first: it relies on asynchronous functions, which have to be handled differently from normal ones. If you&rsquo;ve ever written any JS in the last few years you must&rsquo;ve used a lot of <code>Promise</code>s, <code>async</code>s, and <code>await</code>s, but if you haven&rsquo;t here&rsquo;s a quick reminder.</p></div><pre class="brush: javascript"><code>Promise.resolve(2)
  .then(x =&gt; x + 1)</code></pre><div class="text"><p>The value of <code>Promise.resolve(2)</code> is not quite 2, but rather a <em>computation</em> that yields 2. The only way to increase that 2 is by passing a function to its Promise.</p><p>Javascript does this because it runs on a single thread, and making long blocking computations (like an AJAX request) run synchronously would make the rest of the program, and the whole page it&rsquo;s running on, lock up while it&rsquo;s waiting for that computation to finish, and you really don&rsquo;t want that to happen on your website. But try as you might, you will never be able to make that Promise return a 2, store it in a variable and resume with your normal program flow, like you&rsquo;d do with a normal function (even though the <code>async</code>/<code>await</code> constructs adds a bit of syntactic sugar to make handling Promises similar to normal code).</p><p>The only way to access Promised values you&rsquo;re left with is passing a function to their Promise with the rest of the computations that have to performed on that value. This style of programming is called <strong>continuation-passing style</strong> (CPS).</p></div><h2 class="heading" id="continuations">Continuations</h2><div class="text"><p>Simply put, the continuation to a certain value is the part of the program that needs to wait for that value to continue execution (&ldquo;the rest&rdquo; of the program).</p><p>Continuations are easily represented by functions (but not quite<sup><a href="#g7511-footnote-1-definition" name="g7511-footnote-1-return">1</a></sup>) like the ones you pass to a Promise. Take a simple program <code>stuff() + 2</code>. The continuation of <code>stuff()</code> could be represented by the function <code>x =&gt; x + 2</code>, while the continuation of <code>2</code> would be <code>x =&gt; stuff() + x</code>.</p><p>Promises can never return a value, so the only way to do something with their result is to <em>reify</em> their continuation to a function. Reifying a continuation involves a simple rewrite that wraps the continuation in a function taking one argument, and replaces the value with that argument. This rewrite is applied by many compilers as an intermediate step to simplify the language.</p><p>For example, take the classic definition of the factorial function:</p></div><pre class="brush: javascript"><code>function fact(n) {
  if (n == 0) return 1;
  else return n * fact(n - 1);
}

fact(3); //=&gt; 6</code></pre><div class="text"><p>We could rewrite this in CPS by taking the continuation of the tail invocation of <code>fact</code> and reifying it to a function, then passing that function to <code>fact</code> and calling it on the result.</p></div><pre class="brush: javascript"><code>function factCont(n, cont) {
  if (n == 0) cont(1);
  else factCont(n - 1, x =&gt; cont(n * x));
}

factCont(3, console.log); //=&gt; 6</code></pre><div class="text"><p>If you pass two functions to it, one representing success and the other failure, you have Promises! (without the asynchronicity.)</p><p>For more a more thorough explaination and some advantages of this style, I recommend <a href="http://matt.might.net/articles/by-example-continuation-passing-style/">Matt Might&rsquo;s</a> <a href="http://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/">posts</a> on the topic.</p></div><h2 class="heading" id="callcc">call/cc</h2><div class="text"><p>The problem with CPS is that nobody in their right mind would willingly write their code like this. Most languages offer a few constructs that have similar effects to some of the uses of explicit continuations, such as early returns, exceptions, gotos, or async/await. Others, like Scheme, SML and <a href="https://ruby-doc.org/core-2.4.1/Kernel.html#method-i-callcc">Ruby</a>, give you first class access to raw undelimited continuations through a construct called <em>call-with-current-continuation</em>, abbreviated to <code>call/cc</code> or <code>callcc</code>.</p><p>call/cc takes a function of one argument, and calls it with the current (relative to where call/cc was called) continuation as its argument (historically called <code>k</code>). Invoking <code>k</code> with a value, also referred to as &ldquo;throwing&rdquo;, will set the continuation to that value, thus emulating an early return.</p></div><pre class="brush: scheme"><code>(call/cc
  (lambda (return)
    (display 'before)
    (return)
    (display 'after)))
; =&gt; before</code></pre><div class="text"><p>Storing the current continuation in a mutable cell allows one to return to that point in the program from anywhere else, in a way that&rsquo;s similar to gotos or C&rsquo;s <code>setjmp</code>/<code>longjmp</code>.</p></div><pre class="brush: scheme"><code>(define counter #f)

(let ((x 0))
  ((lambda ()
     (call/cc (lambda (k) (set! counter k)))
     (set! x (+ 1 x))))
  (display x))
; =&gt; 1
(counter) ; =&gt; 2
(counter) ; =&gt; 3</code></pre><div class="text"><p>Combining these two cases, one can implement even more complex and convoluted control flow structures, like exceptions, coroutines, or logic programming-style backtracking. The implementations are <s>a pain to write so I left them out</s> left as an exercise to the reader.</p><p>There have been a number of <a href="http://okmij.org/ftp/continuations/against-callcc.html">points</a> raised against call/cc and first-class access to undelimited continuations, many of which propose <em>delimited</em> continuations as a cleaner, less costly alternative, but I&rsquo;ll be taking a look at those in a later post.</p></div><h2 class="heading" id="sandwiches">Sandwiches</h2><div class="text"><p>Getting back to the sandwich example (or sand-witch, as <a href="https://groups.google.com/forum/#!msg/perl.perl6.language/-KFNPaLL2yE/_RzO8Fenz7AJ">the author of this quote</a> stubbornly calls it):</p></div><blockquote class="text"><p>Say you&rsquo;re in the kitchen in front of the refrigerator, thinking about a sandwitch. You take a continuation right there and stick it in your pocket. Then you get some turkey and bread out of the refrigerator and make yourself a sandwitch, which is now sitting on the counter. You invoke the continuation in your pocket, and you find yourself standing in front of the refrigerator again, thinking about a sandwitch. But fortunately, there&rsquo;s a sandwitch on the counter, and all the materials used to make it are gone. So you eat it. :-)</p></blockquote><div class="text"><p>It becomes obvious once you translate it to code:</p></div><pre class="brush: scheme"><code>(define (eat-sandwich sandwich)
  (display "burp"))

(let ((pocket #f)
      (fridge '(turkey bread))
      (counter '()))
  ; in front of the refrigerator
  (call/cc (lambda (k) (set! pocket k)))
  (if (and (empty? counter) (not (empty? fridge)))
    (let ((sandwich (cons (car fridge) (cadr fridge))))
      (set! fridge '())
      (set! counter (list sandwich))
      (pocket))
    (eat-sandwich (car counter))))
; =&gt; burp</code></pre><div class="text"><p>The program saves its continuation. Then it checks if there&rsquo;s anything on the counter and, finding nothing, it makes the sandwich and invokes the previously saved continuation, returning to the beginning of the conditional. This time it finds a sandwich in the counter, so it can start eating.</p><p>Lucky bastard. It gets to travel back in time, while I&rsquo;m left here writing posts that the past me will never get a glimpse of.</p></div><div class="footnotes"><ol><li id="g7511-footnote-1-definition" class="footnote-definition"><p>It is important to remember that undelimited continuations are not proper functions, because they cannot in any case return a value: in a typed language aware of continuations, a continuation would have a return type equivalent to <a href="http://www.typescriptlang.org/docs/handbook/basic-types.html#never">TypeScript&rsquo;s <code>never</code></a>, or a type annotation like <a href="http://en.cppreference.com/w/c/language/_Noreturn">C&rsquo;s <code>_Noreturn</code></a>. See <a href="http://okmij.org/ftp/continuations/undelimited.html">Oleg Kiselyov&rsquo;s explaination</a> for more information on this.&nbsp;<a href="#g7511-footnote-1-return">↩</a></p></li></ol></div></main><footer>made with <a href="https://racket-lang.org/">racket</a> :: <a href="/rss.xml">rss</a> :: <a href="/feed.xml">atom</a></footer></div></body></html>
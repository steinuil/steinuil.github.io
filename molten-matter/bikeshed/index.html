<html><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" /><title>The social issues of programming languages</title><meta name="description" content="steenuil's blog" /><meta name="generator" content="generator.rkt" /><meta name="referrer" content="strict-origin" /><link rel="stylesheet" href="/assets/style.css" type="text/css" /><link rel="alternate" href="/rss.xml" type="application/rss+xml" title="RSS feed" /><link rel="alternate" href="/feed.xml" type="application/atom+xml" title="Atom feed" /><link rel="apple-touch-icon-precomposed" href="/assets/icon/favicon-152.png" /><meta name="og:type" content="website" /><meta name="og:title" content="The social issues of programming languages" /><meta name="og:description" content="steenuil's blog" /><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@steinuil" /><meta name="twitter:creator" content="@steinuil" /><meta name="twitter:dnt" content="on" /></head><body id="blog-post-page"><div class="body-container"><header><nav><ul><li><a href="/molten-matter/">Molten Matter</a></li><li><a href="/">Links</a></li></ul></nav></header><main><header><h1 class="post-title">The social issues of programming languages</h1> <time datetime="2017-10-29">2017/10/29</time></header><div class="warning text"><p>This post is unlisted. I keep it around to avoid breaking links, but I might have some good reasons to keep it hidden. Please don't repost it.</p></div><div class="text"><p>I&rsquo;m sure you know what bikeshedding means, and even if you don&rsquo;t, you&rsquo;ve probably experienced a high amount of it in some way or another. It&rsquo;s a folkloristic<sup><a href="#g2978-footnote-1-definition" name="g2978-footnote-1-return">1</a></sup> programming term that describes the endless discussion over trivial aspects of a piece of software, such as spaces vs tabs, or which of the zillions of JS build systems to use, or whether operator overloading should be allowed. We&rsquo;ll call these <em>social issues</em>.</p><p>The great thing about social issues is that they only exist when more than one person is working on a project. If it&rsquo;s just you, you don&rsquo;t have to worry about coding style guidelines. You don&rsquo;t have to worry about what paradigm you want to use, or to get everybody comfortable with the set of macros you&rsquo;re using, or with the libraries, or the build system. In fact, you won&rsquo;t have to worry about reproducing the build environment on machines other than your own. You might even get away with not documenting your code, even though your future self will hate you for that.</p><p>Rudolf Winestock in his famous article <a href="http://winestockwebdesign.com/Essays/Lisp_Curse.html">The Lisp Curse</a> argues that <em>&ldquo;Lisp is so powerful that problems which are technical issues in other programming languages are social issues in Lisp.&rdquo;</em> This makes Lisp a great language for lone hackers, because those social issues are easily solved by oneself, but terrible for working with other people, because you&rsquo;ll have to spend so much time just defining a common language that everybody agrees to use that you&rsquo;ll never see the end of it.</p><p>This is a problem in C++, too: the joke goes that the language is so big and full of features that you&rsquo;ll end up using only 10% of it for any given task, but everybody disagrees on what that 10% should be.</p></div><h2 class="heading" id="enter-go">Enter Go</h2><div class="text"><p>Go is a pretty <a href="https://youtu.be/_1GZShA1F20?t=42m13s">unremarkable</a> programming language, with a feature set that <a href="https://cowlark.com/2009-11-15-go/">rivals</a> that of languages from the 60s, and it&rsquo;s also one of the most popular programming languages of the last few years. I think the reason is that whatever thought didn&rsquo;t go into making a good programming language went into solving the social issues that the other languages suffer from, and if you ask people who have experience with many languages what they like about Go they&rsquo;ll mostly praise what you could call its &ldquo;user experience&rdquo;.</p><p>Go tries to solve the social issues by providing solutions for them by default in its standard installation, down to including a code formatter that the vast majority of projects require you to run before committing any code to source control.</p><p>Go also makes lots of tradeoffs in the language itself to make compilation faster: the type system is very limited and you don&rsquo;t get type inference other than some syntactic sugar for C++&rsquo;s <code>auto</code> keyword, because the compiler would have to perform more extensive type checking. Generics also don&rsquo;t exist, because you&rsquo;d have to generate code for each instantiation at compile time.</p><p>I personally don&rsquo;t agree that these tradeoffs are really worth it, but it seems to be working. People love Go (i.e. its tooling), and they love how they don&rsquo;t have to think about all the things Go provides anymore, which I think raises a good point: isn&rsquo;t not worrying about the unimportant parts what programming languages are about? And if so, <strong>what good is a new language that doesn&rsquo;t try to solve these issues?</strong></p></div><h2 class="heading" id="lessons-to-be-learned">Lessons to be learned</h2><div class="text"><p>I think that there&rsquo;s lots of better languages out there that should learn a thing or two from Go, if they want to succeed.</p><p>Elm seems to be a step in the right direction: it takes a lot from Haskell, and makes a lot of decisions and tradeoffs to be easier to learn for newcomers. Elm places a tremendous amount of effort into appealing to newcomers by having a very small core language, integrating many tools into its standard distribution like Go, and making error messages look very friendly and easy to understand.</p><p>Then again, many of these improvements are implemented without regard for the more experienced developers. Elm is a great language and its architecture is a really good paradigm, but many complain that it scales poorly when project sizes increase, and without stronger abstraction facilities like type classes you&rsquo;re bound to end up with a lot of boilerplate. Frankly, I don&rsquo;t think Evan himself knows where he wants to bring the language in the future.</p><p><a href="https://reasonml.github.io/">Reason</a> also seems to be somewhat promising, being funded by Facebook and all. It&rsquo;s nothing but a layer of paint on top of OCaml to make it look more like Javascript, but somehow it&rsquo;s managed to make people buy into it. The Reason team also seems to be working on the OCaml compiler to make it produce error messages that look like Elm&rsquo;s. With a bit of luck, this will bring more people over to OCaml and, over time, improve its ecosystem.</p></div><div class="footnotes"><ol><li id="g2978-footnote-1-definition" class="footnote-definition"><p>I&rsquo;ve stolen this use of the term from <a href="https://www.youtube.com/watch?v=4PaWFYm0kEw">this talk</a> by Bryan Cantrill. It&rsquo;s a good talk.&nbsp;<a href="#g2978-footnote-1-return">â†©</a></p></li></ol></div></main><footer><a href="/molten-matter/">Molten Matter</a> - <a href="/rss.xml">RSS</a> - <a href="/feed.xml">Atom</a></footer></div></body></html>
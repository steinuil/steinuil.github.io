<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <title>steen&#x27;s burrow - patterns</title>
    <subtitle>steen&#x27;s online burrow</subtitle>
    <link rel="self" type="application/atom+xml" href="https://sgt.hootr.club/tags/patterns/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://sgt.hootr.club"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2026-02-01T00:00:00+00:00</updated>
    <id>https://sgt.hootr.club/tags/patterns/atom.xml</id>
    <entry xml:lang="en-us">
        <title>Enumerate your logs</title>
        <published>2026-02-01T00:00:00+00:00</published>
        <updated>2026-02-01T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              steen
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://sgt.hootr.club/blog/enumerate-your-logs/"/>
        <id>https://sgt.hootr.club/blog/enumerate-your-logs/</id>
        
        <content type="html" xml:base="https://sgt.hootr.club/blog/enumerate-your-logs/">&lt;p&gt;I&#x27;m working on my Soulseek client &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;kirarin.hootr.club&#x2F;git&#x2F;steinuil&#x2F;snus&quot;&gt;snus&lt;&#x2F;a&gt; (named in honour of &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;nicotine-plus.org&#x2F;&quot;&gt;nicotine+&lt;&#x2F;a&gt;), which is a Gleam application targeting the BEAM and an attempt to learn some things about OTP. I&#x27;ve also been working on some new projects at work that use structured logging and &quot;audit logging&quot; using structured fields, and I like the pattern! I&#x27;d like snus to have structured logs as well. How do I do it?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-crash-introduction-to-gleam&quot;&gt;A crash introduction to Gleam&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;gleam.run&#x2F;&quot;&gt;Gleam&lt;&#x2F;a&gt; is a very nice programming language with a mauve pink smiling star as a mascot. I like it a lot! I think Gleam is best described as a functional-first ML-like (as in OCaml and SML) language with a Rust-like syntax. In as few words as I can muster:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;It&#x27;s expression-based and has first-class functions, generics, &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;tour.gleam.run&#x2F;everything&#x2F;#data-types-custom-types&quot;&gt;variants&lt;&#x2F;a&gt;, &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;tour.gleam.run&#x2F;everything&#x2F;#advanced-features-opaque-types&quot;&gt;opaque types&lt;&#x2F;a&gt;, pattern matching, tuples, and tail call optimization.&lt;&#x2F;li&gt;
&lt;li&gt;It&#x27;s &quot;strongly&quot; typed, by which I mean that every expression has a type and the only &quot;escape hatch&quot; is foreign function calls AKA &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;tour.gleam.run&#x2F;everything&#x2F;#advanced-features-externals&quot;&gt;externals&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;In terms of syntactic conveniences it has a &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;tour.gleam.run&#x2F;everything&#x2F;#functions-pipelines&quot;&gt;pipe operator&lt;&#x2F;a&gt;, &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;tour.gleam.run&#x2F;everything&#x2F;#functions-labelled-arguments&quot;&gt;labelled arguments&lt;&#x2F;a&gt;, &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;tour.gleam.run&#x2F;everything&#x2F;#data-types-record-accessors&quot;&gt;flow-based record accessors&lt;&#x2F;a&gt; (which sacrifice global type inference for some great syntactical convenience), a very nifty &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;tour.gleam.run&#x2F;everything&#x2F;#advanced-features-use&quot;&gt;&lt;code&gt;use&lt;&#x2F;code&gt; keyword&lt;&#x2F;a&gt; that can act as a &lt;code&gt;do&lt;&#x2F;code&gt; operator and much more, and &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;tour.gleam.run&#x2F;everything&#x2F;#data-types-bit-arrays&quot;&gt;binary pattern matching&lt;&#x2F;a&gt; borrowed from Erlang.&lt;&#x2F;li&gt;
&lt;li&gt;It compiles to both Erlang and JavaScript (and has a nice &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;lustre&#x2F;index.html&quot;&gt;Elm-like framework for single page apps&lt;&#x2F;a&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;It uses a &lt;code&gt;Result(t, err)&lt;&#x2F;code&gt; type to handle errors and it prefers &lt;code&gt;Error(Nil)&lt;&#x2F;code&gt; to &lt;code&gt;option.None&lt;&#x2F;code&gt; in cases where the failure mode is obvious, which encourages a separation of operational failure from a semantical lack of a value.&lt;&#x2F;li&gt;
&lt;li&gt;It uses &lt;code&gt;+&lt;&#x2F;code&gt; for integer addition and &lt;code&gt;+.&lt;&#x2F;code&gt; for float addition like OCaml does, which makes me happy.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;structured-logging&quot;&gt;Structured logging&lt;&#x2F;h2&gt;
&lt;p&gt;Go has a &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;pkg.go.dev&#x2F;log&#x2F;slog&quot;&gt;structured logging library&lt;&#x2F;a&gt; whose functions take an unstructured message, and then pairs of &lt;code&gt;(string, any)&lt;&#x2F;code&gt; as varargs. I don&#x27;t remember which library my workplace uses for structured logging in Python, but I&#x27;m sure it has a similar structured.&lt;&#x2F;p&gt;
&lt;p&gt;Gleam does not have a dictionary&#x2F;hash(map)&#x2F;object literal: it handles dicts just like &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;package.elm-lang.org&#x2F;packages&#x2F;elm&#x2F;core&#x2F;latest&#x2F;Dict&quot;&gt;Elm&lt;&#x2F;a&gt;. You can make a dict from a &lt;code&gt;List&lt;&#x2F;code&gt; of &lt;code&gt;#(key, value)&lt;&#x2F;code&gt; if you want, so if you wanted to reproduce &lt;code&gt;slog&lt;&#x2F;code&gt; in Gleam you&#x27;d have a &lt;code&gt;print(level: LogLevel, data: List(#(String, String)))&lt;&#x2F;code&gt; function. There&#x27;s a &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;glogg&#x2F;index.html&quot;&gt;few&lt;&#x2F;a&gt; &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;flash&#x2F;index.html&quot;&gt;structured&lt;&#x2F;a&gt; &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;glight&#x2F;index.html&quot;&gt;logging&lt;&#x2F;a&gt; &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;gclog&#x2F;index.html&quot;&gt;libraries&lt;&#x2F;a&gt; on the &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;packages.gleam.run&#x2F;&quot;&gt;Gleam package index&lt;&#x2F;a&gt; that fit the bill, but I didn&#x27;t like any of them and I was wondering how I could reconsider that approach.&lt;&#x2F;p&gt;
&lt;p&gt;Gleam doesn&#x27;t have a built-in syntax for booleans; &lt;code&gt;Bool&lt;&#x2F;code&gt; is a &quot;custom type&quot; like any other that could just as easily be defined in a library:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #D8DEE9; background-color: #2E3440;&quot;&gt;&lt;code data-lang=&quot;gleam&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: #81A1C1;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt; Bool {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  True&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  False&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Booleans could just as well be reprenented as the strings &lt;code&gt;&quot;true&quot;&lt;&#x2F;code&gt; and &lt;code&gt;&quot;false&quot;&lt;&#x2F;code&gt;, but languages like Gleam and OCaml and Rust and C# and Java and Go choose to represent booleans as their own type. How many states could a &lt;code&gt;String&lt;&#x2F;code&gt; have compared to a &lt;code&gt;Bool&lt;&#x2F;code&gt;? Would you say, &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=EWKB86iSlFo&quot;&gt;ten million&lt;&#x2F;a&gt;?&lt;&#x2F;p&gt;
&lt;p&gt;Now think about your application&#x27;s logs. How many states that are meaningful enough to be logged does your service have? Can you enumerate all of them? Can you gracefully handle the failures? Does the user need to know about it? Is it useful for debugging? Will the log message have to be localized at some point?&lt;&#x2F;p&gt;
&lt;p&gt;There&#x27;s &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;glight&quot;&gt;several&lt;&#x2F;a&gt; &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;glogg&quot;&gt;structured&lt;&#x2F;a&gt; &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;flash&quot;&gt;logging&lt;&#x2F;a&gt; &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;birch&quot;&gt;libraries&lt;&#x2F;a&gt; &lt;a class=&quot;external-link&quot; rel=&quot;nofollow noreferrer external&quot; href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;viva_telemetry&#x2F;index.html&quot;&gt;available&lt;&#x2F;a&gt; in the Gleam package registry. Gleam is a new language whose library ecosystem is still growing, none of these libraries seem to be leading the pack, so I&#x27;m not sure I should be committing to any of them. Instead I added a &lt;code&gt;logging&lt;&#x2F;code&gt; module containing a &lt;code&gt;Log&lt;&#x2F;code&gt; variant that contains all the types of things I want to be logging in the application, along with some data that I think will be useful to debug any problems. This will let me easily switch logging implementation in the future, but I think it&#x27;s also a good pattern to keep in my toolbox.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color: #D8DEE9; background-color: #2E3440;&quot;&gt;&lt;code data-lang=&quot;gleam&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: #81A1C1;&quot;&gt;pub type&lt;&#x2F;span&gt;&lt;span&gt; Log {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  PeerAlreadyConnected(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    conn_type: ConnectionType,&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    ip: IP,&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    port: Int,&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  )&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  PeerViolatedConnectionOrder(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    username: String,&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    message: String,&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  )&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: #616E88;&quot;&gt;  &#x2F;&#x2F; ...&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Enumerating special cases in a program is a way to give them semantical meaning. I think logs can be as deserving of care and thought as much as the important part of our applications: maybe just the act of adding the failure case can give you a chance to think about it more carefully. Consider enumerating your logs.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>

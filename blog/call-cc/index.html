<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1,viewport-fit=cover" name=viewport><title>Continuations, Promises, and call/cc</title><meta content="steen's online burrow" name=description><meta content=Zola name=generator><meta content=strict-origin name=referrer><link href=https://sgt.hootr.club/assets/style.css rel=stylesheet><link title="RSS feed" href=/rss.xml rel=alternate type=application/rss+xml><link title="Atom feed" href=/atom.xml rel=alternate type=application/atom+xml><link href=/assets/icon/favicon-152.png rel=apple-touch-icon-precomposed><body class=main-parent><div class=main-parent><header class=main><h1 class=header-title><a href=https://sgt.hootr.club>STEENSBURROW</a></h1><nav><ul class=unstyled><li><a class=unstyled href=https://sgt.hootr.club/me/>me</a><li><a class=unstyled href=https://sgt.hootr.club/blog/>posts</a><li><a class=unstyled href=https://sgt.hootr.club/meta/>meta</a></ul></nav></header><main class=main><article><header><h1 class=title>Continuations, Promises, and call/cc</h1><p class=subtitle>Published by <a href=/><i>steen</i></a> on <time datetime=2017-10-27>2017-10-27</time> tagged <a class=tag href=https://sgt.hootr.club/tags/scheme/>#scheme</a> <a class=tag href=https://sgt.hootr.club/tags/typescript/>#typescript</a></header><div class=content><p>Say you're in the kitchen in front of the refrigerator, thinking about continuations. You make yourself a sandwich right there and stick it on your desk. Then you sit on your armchair and open a browser window to search for their definition. You get a series of abstract explainations, and some examples involving fridges and sandwiches, which leave you more puzzled than when you began. You invoke the sandwich on your desk, and you find yourself wondering if the topic is even worth going through all this trouble to learn about.<h2 id=promises>Promises</h2><p>Javascript has a concurrency model which can be somewhat daunting at first: it relies on asynchronous functions, which have to be handled differently from normal ones. If you've ever written any JS in the last few years you must've used a lot of <code>Promise</code>s, <code>async</code>s, and <code>await</code>s, but if you haven't here's a quick reminder.<pre class=language-javascript data-lang=javascript style=color:#d8dee9;background-color:#2e3440><code class=language-javascript data-lang=javascript><span style=color:#8fbcbb>Promise</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>resolve</span><span>(</span><span style=color:#b48ead>2</span><span>)
</span><span>  </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>then</span><span>(x </span><span style=color:#81a1c1>=> </span><span>x </span><span style=color:#81a1c1>+ </span><span style=color:#b48ead>1</span><span>)
</span></code></pre><p>The value of <code>Promise.resolve(2)</code> is not quite 2, but rather a <em>computation</em> that yields 2. The only way to increase that 2 is by passing a function to its Promise.<p>Javascript does this because it runs on a single thread, and making long blocking computations (like an AJAX request) run synchronously would make the rest of the program, and the whole page it's running on, lock up while it's waiting for that computation to finish, and you really don't want that to happen on your website. But try as you might, you will never be able to make that Promise return a 2, store it in a variable and resume with your normal program flow, like you'd do with a normal function (even though the <code>async</code>/<code>await</code> constructs adds a bit of syntactic sugar to make handling Promises similar to normal code).<p>The only way to access Promised values you're left with is passing a function to their Promise with the rest of the computations that have to performed on that value. This style of programming is called <strong>continuation-passing style</strong> (CPS).<h2 id=continuations>Continuations</h2><p>Simply put, the continuation to a certain value is the part of the program that needs to wait for that value to continue execution ("the rest" of the program).<p>Continuations are easily represented by functions (but not quite<sup class=footnote-reference><a href=#1>1</a></sup>) like the ones you pass to a Promise. Take a simple program <code>stuff() + 2</code>. The continuation of <code>stuff()</code> could be represented by the function <code>x => x + 2</code>, while the continuation of <code>2</code> would be <code>x => stuff() + x</code>.<p>Promises can never return a value, so the only way to do something with their result is to <em>reify</em> their continuation to a function. Reifying a continuation involves a simple rewrite that wraps the continuation in a function taking one argument, and replaces the value with that argument. This rewrite is applied by many compilers as an intermediate step to simplify the language.<p>For example, take the classic definition of the factorial function:<pre class=language-javascript data-lang=javascript style=color:#d8dee9;background-color:#2e3440><code class=language-javascript data-lang=javascript><span style=color:#81a1c1>function </span><span style=color:#88c0d0>fact</span><span>(n) {
</span><span>  </span><span style=color:#81a1c1>if </span><span>(n </span><span style=color:#81a1c1>== </span><span style=color:#b48ead>0</span><span>) </span><span style=color:#81a1c1>return </span><span style=color:#b48ead>1</span><span style=color:#eceff4>;
</span><span>  </span><span style=color:#81a1c1>else return </span><span>n </span><span style=color:#81a1c1>* </span><span style=color:#88c0d0>fact</span><span>(n </span><span style=color:#81a1c1>- </span><span style=color:#b48ead>1</span><span>)</span><span style=color:#eceff4>;
</span><span>}
</span><span>
</span><span style=color:#88c0d0>fact</span><span>(</span><span style=color:#b48ead>3</span><span>)</span><span style=color:#eceff4>; </span><span style=color:#616e88>//=> 6
</span></code></pre><p>We could rewrite this in CPS by taking the continuation of the tail invocation of <code>fact</code> and reifying it to a function, then passing that function to <code>fact</code> and calling it on the result.<pre class=language-javascript data-lang=javascript style=color:#d8dee9;background-color:#2e3440><code class=language-javascript data-lang=javascript><span style=color:#81a1c1>function </span><span style=color:#88c0d0>factCont</span><span>(n</span><span style=color:#eceff4>, </span><span>cont) {
</span><span>  </span><span style=color:#81a1c1>if </span><span>(n </span><span style=color:#81a1c1>== </span><span style=color:#b48ead>0</span><span>) </span><span style=color:#88c0d0>cont</span><span>(</span><span style=color:#b48ead>1</span><span>)</span><span style=color:#eceff4>;
</span><span>  </span><span style=color:#81a1c1>else </span><span style=color:#88c0d0>factCont</span><span>(n </span><span style=color:#81a1c1>- </span><span style=color:#b48ead>1</span><span style=color:#eceff4>, </span><span>x </span><span style=color:#81a1c1>=> </span><span style=color:#88c0d0>cont</span><span>(n </span><span style=color:#81a1c1>* </span><span>x))</span><span style=color:#eceff4>;
</span><span>}
</span><span>
</span><span style=color:#88c0d0>factCont</span><span>(</span><span style=color:#b48ead>3</span><span style=color:#eceff4>, </span><span style=color:#8fbcbb>console</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>log</span><span>)</span><span style=color:#eceff4>; </span><span style=color:#616e88>//=> 6
</span></code></pre><p>If you pass two functions to it, one representing success and the other failure, you have Promises! (without the asynchronicity.)<p>For more a more thorough explaination and some advantages of this style, I recommend <a rel="nofollow noreferrer" class=external-link href=http://matt.might.net/articles/by-example-continuation-passing-style/>Matt Might's</a> <a rel="nofollow noreferrer" class=external-link href=http://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/>posts</a> on the topic.<h2 id=call-cc>call/cc</h2><p>The problem with CPS is that nobody in their right mind would willingly write their code like this. Most languages offer a few constructs that have similar effects to some of the uses of explicit continuations, such as early returns, exceptions, gotos, or async/await. Others, like Scheme, SML and <a rel="nofollow noreferrer" class=external-link href=https://ruby-doc.org/core-2.4.1/Kernel.html#method-i-callcc>Ruby</a>, give you first class access to raw undelimited continuations through a construct called <em>call-with-current-continuation</em>, abbreviated to <code>call/cc</code> or <code>callcc</code>.<p>call/cc takes a function of one argument, and calls it with the current (relative to where call/cc was called) continuation as its argument (historically called <code>k</code>). Invoking <code>k</code> with a value, also referred to as "throwing", will set the continuation to that value, thus emulating an early return.<pre class=language-lisp data-lang=lisp style=color:#d8dee9;background-color:#2e3440><code class=language-lisp data-lang=lisp><span>(call</span><span style=color:#81a1c1>/</span><span>cc
</span><span>  (</span><span style=color:#88c0d0>lambda </span><span>(</span><span style=color:#81a1c1>return</span><span>)
</span><span>    (display 'before)
</span><span>    (</span><span style=color:#81a1c1>return</span><span>)
</span><span>    (display 'after)))
</span><span style=color:#616e88>; => before
</span></code></pre><p>Storing the current continuation in a mutable cell allows one to return to that point in the program from anywhere else, in a way that's similar to gotos or C's <code>setjmp</code>/<code>longjmp</code>.<pre class=language-lisp data-lang=lisp style=color:#d8dee9;background-color:#2e3440><code class=language-lisp data-lang=lisp><span>(define counter #f)
</span><span>
</span><span>(</span><span style=color:#81a1c1>let </span><span>((x </span><span style=color:#b48ead>0</span><span>))
</span><span>  ((</span><span style=color:#88c0d0>lambda </span><span>()
</span><span>     (call</span><span style=color:#81a1c1>/</span><span>cc (</span><span style=color:#88c0d0>lambda </span><span>(k) (</span><span style=color:#88c0d0>set</span><span>! counter k)))
</span><span>     (</span><span style=color:#88c0d0>set</span><span>! x (</span><span style=color:#81a1c1>+ </span><span style=color:#b48ead>1</span><span> x))))
</span><span>  (display x))
</span><span style=color:#616e88>; => 1
</span><span>(counter) </span><span style=color:#616e88>; => 2
</span><span>(counter) </span><span style=color:#616e88>; => 3
</span></code></pre><p>Combining these two cases, one can implement even more complex and convoluted control flow structures, like exceptions, coroutines, or logic programming-style backtracking. The implementations are <s>a pain to write so I left them out</s> left as an exercise to the reader.<p>There have been a number of <a rel="nofollow noreferrer" class=external-link href=http://okmij.org/ftp/continuations/against-callcc.html>points</a> raised against call/cc and first-class access to undelimited continuations, many of which propose <em>delimited</em> continuations as a cleaner, less costly alternative, but I'll be taking a look at those in a later post.<h2 id=sandwiches>Sandwiches</h2><p>Getting back to the sandwich example (or sand-witch, as <a rel="nofollow noreferrer" class=external-link href=https://groups.google.com/forum/#!msg/perl.perl6.language/-KFNPaLL2yE/_RzO8Fenz7AJ>the author of this quote</a> stubbornly calls it):<blockquote><p>Say you're in the kitchen in front of the refrigerator, thinking about a sandwitch. You take a continuation right there and stick it in your pocket. Then you get some turkey and bread out of the refrigerator and make yourself a sandwitch, which is now sitting on the counter. You invoke the continuation in your pocket, and you find yourself standing in front of the refrigerator again, thinking about a sandwitch. But fortunately, there's a sandwitch on the counter, and all the materials used to make it are gone. So you eat it. :-)</blockquote><p>It becomes obvious once you translate it to code:<pre class=language-lisp data-lang=lisp style=color:#d8dee9;background-color:#2e3440><code class=language-lisp data-lang=lisp><span>(define (eat</span><span style=color:#81a1c1>-</span><span>sandwich sandwich)
</span><span>  (display </span><span style=color:#a3be8c>"burp"</span><span>))
</span><span>
</span><span>(</span><span style=color:#81a1c1>let </span><span>((pocket #f)
</span><span>      (fridge '(turkey bread))
</span><span>      (counter '()))
</span><span>  </span><span style=color:#616e88>; in front of the refrigerator
</span><span>  (call</span><span style=color:#81a1c1>/</span><span>cc (</span><span style=color:#88c0d0>lambda </span><span>(k) (</span><span style=color:#88c0d0>set</span><span>! pocket k)))
</span><span>  (</span><span style=color:#81a1c1>if </span><span>(</span><span style=color:#81a1c1>and </span><span>(empty? counter) (</span><span style=color:#81a1c1>not </span><span>(empty? fridge)))
</span><span>    (</span><span style=color:#81a1c1>let </span><span>((sandwich (</span><span style=color:#88c0d0>cons </span><span>(</span><span style=color:#88c0d0>car</span><span> fridge) (</span><span style=color:#88c0d0>cadr</span><span> fridge))))
</span><span>      (</span><span style=color:#88c0d0>set</span><span>! fridge '())
</span><span>      (</span><span style=color:#88c0d0>set</span><span>! counter (</span><span style=color:#88c0d0>list</span><span> sandwich))
</span><span>      (pocket))
</span><span>    (eat</span><span style=color:#81a1c1>-</span><span>sandwich (</span><span style=color:#88c0d0>car</span><span> counter))))
</span><span style=color:#616e88>; => burp
</span></code></pre><p>The program saves its continuation. Then it checks if there's anything on the counter and, finding nothing, it makes the sandwich and invokes the previously saved continuation, returning to the beginning of the conditional. This time it finds a sandwich in the counter, so it can start eating.<p>Lucky bastard. It gets to travel back in time, while I'm left here writing posts that the past me will never get a glimpse of.<div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p>It is important to remember that undelimited continuations are not proper functions, because they cannot in any case return a value: in a typed language aware of continuations, a continuation would have a return type equivalent to <a rel="nofollow noreferrer" class=external-link href=http://www.typescriptlang.org/docs/handbook/basic-types.html#never>TypeScript's <code>never</code></a>, or a type annotation like <a rel="nofollow noreferrer" class=external-link href=http://en.cppreference.com/w/c/language/_Noreturn>C's <code>_Noreturn</code></a>. See <a rel="nofollow noreferrer" class=external-link href=http://okmij.org/ftp/continuations/undelimited.html>Oleg Kiselyov's explaination</a> for more information on this.</div></div></article></main><footer class=main><a class=logo href=/> <svg viewbox="0 0 79 49" version=1.1 xmlns=http://www.w3.org/2000/svg xmlns:svg=http://www.w3.org/2000/svg><title>Steen's online burrow</title><g fill=currentColor><g><path d="M 17,7 V 9 H 15 V 8 h -1 v 3 h 1 v 1 h 2 v 1 h 4 V 9 H 20 V 8 H 19 V 5 h 1 V 4 h 1 V 3 h 4 v 1 h -3 v 3 h 1 v 1 h 1 v 4 h -1 v 1 h -1 c 0,0 0,1 0,1 H 16 V 13 H 13 V 12 10 H 12 V 8 h 1 V 7 Z"/><path d="m 30,5 v 1 h 2 V 5 h 3 v 1 h -2 v 1 h -2 v 4 h -1 v 1 h -1 v 1 h -1 c 0,0 0,2 0,2 h -1 c 0,0 0,1 0,1 h -1 v -3 h 1 v -2 h 1 V 7 H 26 V 6 H 24 V 5 Z"/><path d="m 39,5 v 2 h -1 c 0,0 0,1 0,1 h -1 c 0,0 0,1 0,1 h -2 v 1 h 4 c 0,0 0,2 0,2 h -2 v -1 h -3 v 1 h -1 v 2 h 2 v -1 h 3 v 1 h 1 v 1 h 1 c 0,0 0,1 0,1 h -2 v -1 h -4 c 0,0 0,1 0,1 h -4 v -1 h 1 v -2 h 1 v -2 h 1 V 8 h 3 V 7 h 1 V 6 h 1 V 5 Z"/><path d="m 42,5 v 1 h 1 v 1 h 1 v 1 h 1 v 1 h 2 v 1 H 44 V 9 h -1 v 2 h 3 v 1 h -2 v 1 h -1 v 1 h 2 v -1 h 2 v 2 h -4 c 0,0 0,1 0,1 h -2 v -2 h 1 V 9 H 41 V 7 H 40 V 5 Z"/><path d="m 48,6 v 2 h 1 v 4 h 1 c 0,0 0,2 0,2 h -1 v 3 c 0,0 1,0 1,0 v -1 h 1 v -2 h 1 v -2 h 1 v 1 h 1 v 1 h 1 v 1 h 2 V 14 H 56 V 9 h 1 V 7 h 1 V 5 h 1 V 4 h 1 V 2 h -1 v 1 h -2 v 1 h -1 v 4 h -1 v 4 H 54 V 11 H 53 V 10 H 51 V 8 H 50 V 7 H 49 V 6 Z"/><path d="m 61,0 v 1 h 1 v 3 h 2 V 2 H 63 V 0 Z"/><path d="m 67,4 v 1 h -1 v 2 h 1 c 0,0 0,3 0,3 h -1 v 1 c 0,0 -4,0 -4,0 v -1 h 2 V 9 h 1 V 8 H 64 V 5 h 1 V 4 Z"/></g><g><path d="m 26,22 h 3 v -1 h -3 z"/><path d="m 31,20 v 1 h 1 v 1 h 1 v -2 z m 1,2 h -1 v -1 h -1 v 2 h 2 z"/><path d="m 34,20 v 3 h 1 v -2 h 1 v 2 h 1 v -2 h -1 v -1 z"/><path d="m 38,19 v 4 h 1 v -4 z"/><path d="m 40,19 v 1 h 1 v -1 z"/><path d="m 40,21 v 2 h 1 v -2 z"/><path d="m 42,23 v -3 h 2 v 1 h 1 c 0,0 0,2 0,2 h -1 v -2 h -1 v 2 z"/><path d="m 46,21 v 2 h 1 v 1 h 1 v -1 h -1 v -2 h 1 v 1 h 1 v -2 h -2 v 1 z"/><path d="m 50,21 c 0,0 0,1 0,1 h 3 v -1 z"/></g><g><path d="m 5,26 v 1 H 4 v 6 H 3 v 7 H 2 v 4 H 1 v 2 H 0 v 3 h 6 v -1 h 2 v -1 h 2 v -1 h 2 v -1 h 2 v -4 h -1 v -1 h -1 v -2 h 1 v -2 h 1 v -1 h 1 v -1 h 1 V 28 H 12 V 27 H 9 v -1 z m 2,4 h 2 v 1 h 3 v 2 h -1 v 1 h -1 v 1 H 9 v 1 H 8 v 1 H 6 V 36 H 7 Z M 6,41 h 2 v 1 h 2 v 1 H 8 v 1 H 6 v 1 H 5 v -2 h 1 z"/><path d="m 17,26 v 3 h 1 v 2 h -1 v 5 h -1 v 4 h -1 v 4 h 1 v 2 h 9 v -1 h 1 v -3 h 1 V 25 h -4 v 5 h 1 v 9 h -1 v 3 h -1 v 1 h -3 v -4 h 1 v -5 h 1 v -8 z"/><path d="m 28,27 v 5 h 1 v 2 h -1 v 14 h 3 V 38 h 1 v 4 h 1 v 4 h 1 v 2 h 3 v -5 h -1 v -4 h -1 v -5 h 3 v -6 h -2 v -1 z m 4,3 h 1 v 1 h -1 z"/><path d="m 40,27 v 21 h 3 V 37 h 1 v 1 h 1 v 1 h 1 v 1 h 1 v 2 h 1 v 1 h 1 v 2 h 4 v -3 h -1 v -1 h -1 v -2 h -1 v -1 h -1 v -1 h -1 v -9 h -2 v -1 z m 3,4 h 2 v 1 h -1 v 1 h -1 z"/><path d="m 52,27 v 1 h -1 v 1 h -1 v 7 h 1 v 1 h 1 v 1 h 1 v 1 h 5 v -1 h 2 v -1 h 1 v -8 h -1 v -1 h -4 v -1 z m 2,4 h 3 v 1 h 1 v 2 h -1 v 1 h -2 v -1 h -1 v -1 h -1 v -1 h 1 z"/><path d="m 63,25 v 4 h 1 v 16 h 4 v -1 h 1 v -1 h 1 v -2 h 2 v 1 h 2 v 1 h 1 v 1 h 4 v -5 h -1 v -3 h -1 v -2 h -1 v -2 h -1 v -2 h -1 v -2 h -1 v -3 h -1 v -1 h -3 v 4 h 1 v 3 h 1 v 2 h 1 v 2 h 1 v 2 h 1 v 1 h -1 v -1 h -4 v 1 H 67 V 26 h -1 v -1 z"/></g></g></svg> </a><div class=blurb>There is no end though there is a start in the past — Infinity.<br> It speaks, it ruins, and it goes though it consumes the soul — Finite.<br> Only the person who has wisdom can read the most foolish one from the history.<br> The daemon that lives in the machine doesn't understand the daemon that lives in the brain.<br> It is funnier that man exceeds the speed of light than machine start writing on a net.<br> It can be said that this is final ultimatum from the people who can think.</div></footer></div>
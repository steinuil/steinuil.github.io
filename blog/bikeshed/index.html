<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1,viewport-fit=cover" name=viewport><title>The social issues of programming languages</title><meta content="steen's online burrow" name=description><meta content=Zola name=generator><meta content=strict-origin name=referrer><link href=https://sgt.hootr.club/assets/style.css rel=stylesheet><link title="RSS feed" href=/rss.xml rel=alternate type=application/rss+xml><link title="Atom feed" href=/atom.xml rel=alternate type=application/atom+xml><link href=/assets/icon/favicon-152.png rel=apple-touch-icon-precomposed><body class=main-parent><div class=main-parent><header class=main><h1 class=header-title><a href=https://sgt.hootr.club>STEENSBURROW</a></h1><nav><ul class=unstyled><li><a class=unstyled href=https://sgt.hootr.club/me/>me</a><li><a class=unstyled href=https://sgt.hootr.club/blog/>posts</a><li><a class=unstyled href=https://sgt.hootr.club/meta/>meta</a></ul></nav></header><main class=main><article><header><h1 class=title>The social issues of programming languages</h1><p class=subtitle>Published by <a href=/><i>steen</i></a> on <time datetime=2017-10-29>2017-10-29</time> tagged <a class=tag href=https://sgt.hootr.club/tags/go/>#go</a> <a class=tag href=https://sgt.hootr.club/tags/musings/>#musings</a></header><div class=content><p>I'm sure you know what bikeshedding means, and even if you don't, you've probably experienced a high amount of it in some way or another. It's a folkloristic<sup class=footnote-reference><a href=#1>1</a></sup> programming term that describes the endless discussion over trivial aspects of a piece of software, such as spaces vs tabs, or which of the zillions of JS build systems to use, or whether operator overloading should be allowed. We'll call these <em>social issues</em>.<p>The great thing about social issues is that they only exist when more than one person is working on a project. If it's just you, you don't have to worry about coding style guidelines. You don't have to worry about what paradigm you want to use, or to get everybody comfortable with the set of macros you're using, or with the libraries, or the build system. In fact, you won't have to worry about reproducing the build environment on machines other than your own. You might even get away with not documenting your code, even though your future self will hate you for that.<p>Rudolf Winestock in his famous article <a rel="nofollow noreferrer" class=external-link href=http://winestockwebdesign.com/Essays/Lisp_Curse.html>The Lisp Curse</a> argues that <em>"Lisp is so powerful that problems which are technical issues in other programming languages are social issues in Lisp."</em> This makes Lisp a great language for lone hackers, because those social issues are easily solved by oneself, but terrible for working with other people, because you'll have to spend so much time just defining a common language that everybody agrees to use that you'll never see the end of it.<p>This is a problem in C++, too: the joke goes that the language is so big and full of features that you'll end up using only 10% of it for any given task, but everybody disagrees on what that 10% should be.<h2 id=enter-go>Enter Go</h2><p>Go is a pretty <a href="https://youtu.be/_1GZShA1F20?t=42m13s" rel="nofollow noreferrer" class=external-link>unremarkable</a> programming language, with a feature set that <a rel="nofollow noreferrer" class=external-link href=https://cowlark.com/2009-11-15-go/>rivals</a> that of languages from the 60s, and it's also one of the most popular programming languages of the last few years. I think the reason is that whatever thought didn't go into making a good programming language went into solving the social issues that the other languages suffer from, and if you ask people who have experience with many languages what they like about Go they'll mostly praise what you could call its "user experience".<p>Go tries to solve the social issues by providing solutions for them by default in its standard installation, down to including a code formatter that the vast majority of projects require you to run before committing any code to source control.<p>Go also makes lots of tradeoffs in the language itself to make compilation faster: the type system is very limited and you don't get type inference other than some syntactic sugar for C++'s <code>auto</code> keyword, because the compiler would have to perform more extensive type checking. Generics also don't exist, because you'd have to generate code for each instantiation at compile time.<p>I personally don't agree that these tradeoffs are really worth it, but it seems to be working. People love Go (i.e. its tooling), and they love how they don't have to think about all the things Go provides anymore, which I think raises a good point: isn't not worrying about the unimportant parts what programming languages are about? And if so, <strong>what good is a new language that doesn't try to solve these issues?</strong><h2 id=lessons-to-be-learned>Lessons to be learned</h2><p>I think that there's lots of better languages out there that should learn a thing or two from Go, if they want to succeed.<p>Elm seems to be a step in the right direction: it takes a lot from Haskell, and makes a lot of decisions and tradeoffs to be easier to learn for newcomers. Elm places a tremendous amount of effort into appealing to newcomers by having a very small core language, integrating many tools into its standard distribution like Go, and making error messages look very friendly and easy to understand.<p>Then again, many of these improvements are implemented without regard for the more experienced developers. Elm is a great language and its architecture is a really good paradigm, but many complain that it scales poorly when project sizes increase, and without stronger abstraction facilities like type classes you're bound to end up with a lot of boilerplate. Frankly, I don't think Evan himself knows where he wants to bring the language in the future.<p><a rel="nofollow noreferrer" class=external-link href=https://reasonml.github.io/>Reason</a> also seems to be somewhat promising, being funded by Facebook and all. It's nothing but a layer of paint on top of OCaml to make it look more like Javascript, but somehow it's managed to make people buy into it. The Reason team also seems to be working on the OCaml compiler to make it produce error messages that look like Elm's. With a bit of luck, this will bring more people over to OCaml and, over time, improve its ecosystem.<div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p>I've stolen this use of the term from <a href="https://www.youtube.com/watch?v=4PaWFYm0kEw" rel="nofollow noreferrer" class=external-link>this talk</a> by Bryan Cantrill. It's a good talk.</div></div></article></main><footer class=main><a class=logo href=/> <svg viewbox="0 0 79 49" version=1.1 xmlns=http://www.w3.org/2000/svg xmlns:svg=http://www.w3.org/2000/svg><title>Steen's online burrow</title><g fill=currentColor><g><path d="M 17,7 V 9 H 15 V 8 h -1 v 3 h 1 v 1 h 2 v 1 h 4 V 9 H 20 V 8 H 19 V 5 h 1 V 4 h 1 V 3 h 4 v 1 h -3 v 3 h 1 v 1 h 1 v 4 h -1 v 1 h -1 c 0,0 0,1 0,1 H 16 V 13 H 13 V 12 10 H 12 V 8 h 1 V 7 Z"/><path d="m 30,5 v 1 h 2 V 5 h 3 v 1 h -2 v 1 h -2 v 4 h -1 v 1 h -1 v 1 h -1 c 0,0 0,2 0,2 h -1 c 0,0 0,1 0,1 h -1 v -3 h 1 v -2 h 1 V 7 H 26 V 6 H 24 V 5 Z"/><path d="m 39,5 v 2 h -1 c 0,0 0,1 0,1 h -1 c 0,0 0,1 0,1 h -2 v 1 h 4 c 0,0 0,2 0,2 h -2 v -1 h -3 v 1 h -1 v 2 h 2 v -1 h 3 v 1 h 1 v 1 h 1 c 0,0 0,1 0,1 h -2 v -1 h -4 c 0,0 0,1 0,1 h -4 v -1 h 1 v -2 h 1 v -2 h 1 V 8 h 3 V 7 h 1 V 6 h 1 V 5 Z"/><path d="m 42,5 v 1 h 1 v 1 h 1 v 1 h 1 v 1 h 2 v 1 H 44 V 9 h -1 v 2 h 3 v 1 h -2 v 1 h -1 v 1 h 2 v -1 h 2 v 2 h -4 c 0,0 0,1 0,1 h -2 v -2 h 1 V 9 H 41 V 7 H 40 V 5 Z"/><path d="m 48,6 v 2 h 1 v 4 h 1 c 0,0 0,2 0,2 h -1 v 3 c 0,0 1,0 1,0 v -1 h 1 v -2 h 1 v -2 h 1 v 1 h 1 v 1 h 1 v 1 h 2 V 14 H 56 V 9 h 1 V 7 h 1 V 5 h 1 V 4 h 1 V 2 h -1 v 1 h -2 v 1 h -1 v 4 h -1 v 4 H 54 V 11 H 53 V 10 H 51 V 8 H 50 V 7 H 49 V 6 Z"/><path d="m 61,0 v 1 h 1 v 3 h 2 V 2 H 63 V 0 Z"/><path d="m 67,4 v 1 h -1 v 2 h 1 c 0,0 0,3 0,3 h -1 v 1 c 0,0 -4,0 -4,0 v -1 h 2 V 9 h 1 V 8 H 64 V 5 h 1 V 4 Z"/></g><g><path d="m 26,22 h 3 v -1 h -3 z"/><path d="m 31,20 v 1 h 1 v 1 h 1 v -2 z m 1,2 h -1 v -1 h -1 v 2 h 2 z"/><path d="m 34,20 v 3 h 1 v -2 h 1 v 2 h 1 v -2 h -1 v -1 z"/><path d="m 38,19 v 4 h 1 v -4 z"/><path d="m 40,19 v 1 h 1 v -1 z"/><path d="m 40,21 v 2 h 1 v -2 z"/><path d="m 42,23 v -3 h 2 v 1 h 1 c 0,0 0,2 0,2 h -1 v -2 h -1 v 2 z"/><path d="m 46,21 v 2 h 1 v 1 h 1 v -1 h -1 v -2 h 1 v 1 h 1 v -2 h -2 v 1 z"/><path d="m 50,21 c 0,0 0,1 0,1 h 3 v -1 z"/></g><g><path d="m 5,26 v 1 H 4 v 6 H 3 v 7 H 2 v 4 H 1 v 2 H 0 v 3 h 6 v -1 h 2 v -1 h 2 v -1 h 2 v -1 h 2 v -4 h -1 v -1 h -1 v -2 h 1 v -2 h 1 v -1 h 1 v -1 h 1 V 28 H 12 V 27 H 9 v -1 z m 2,4 h 2 v 1 h 3 v 2 h -1 v 1 h -1 v 1 H 9 v 1 H 8 v 1 H 6 V 36 H 7 Z M 6,41 h 2 v 1 h 2 v 1 H 8 v 1 H 6 v 1 H 5 v -2 h 1 z"/><path d="m 17,26 v 3 h 1 v 2 h -1 v 5 h -1 v 4 h -1 v 4 h 1 v 2 h 9 v -1 h 1 v -3 h 1 V 25 h -4 v 5 h 1 v 9 h -1 v 3 h -1 v 1 h -3 v -4 h 1 v -5 h 1 v -8 z"/><path d="m 28,27 v 5 h 1 v 2 h -1 v 14 h 3 V 38 h 1 v 4 h 1 v 4 h 1 v 2 h 3 v -5 h -1 v -4 h -1 v -5 h 3 v -6 h -2 v -1 z m 4,3 h 1 v 1 h -1 z"/><path d="m 40,27 v 21 h 3 V 37 h 1 v 1 h 1 v 1 h 1 v 1 h 1 v 2 h 1 v 1 h 1 v 2 h 4 v -3 h -1 v -1 h -1 v -2 h -1 v -1 h -1 v -1 h -1 v -9 h -2 v -1 z m 3,4 h 2 v 1 h -1 v 1 h -1 z"/><path d="m 52,27 v 1 h -1 v 1 h -1 v 7 h 1 v 1 h 1 v 1 h 1 v 1 h 5 v -1 h 2 v -1 h 1 v -8 h -1 v -1 h -4 v -1 z m 2,4 h 3 v 1 h 1 v 2 h -1 v 1 h -2 v -1 h -1 v -1 h -1 v -1 h 1 z"/><path d="m 63,25 v 4 h 1 v 16 h 4 v -1 h 1 v -1 h 1 v -2 h 2 v 1 h 2 v 1 h 1 v 1 h 4 v -5 h -1 v -3 h -1 v -2 h -1 v -2 h -1 v -2 h -1 v -2 h -1 v -3 h -1 v -1 h -3 v 4 h 1 v 3 h 1 v 2 h 1 v 2 h 1 v 2 h 1 v 1 h -1 v -1 h -4 v 1 H 67 V 26 h -1 v -1 z"/></g></g></svg> </a><div class=blurb>There is no end though there is a start in the past — Infinity.<br> It speaks, it ruins, and it goes though it consumes the soul — Finite.<br> Only the person who has wisdom can read the most foolish one from the history.<br> The daemon that lives in the machine doesn't understand the daemon that lives in the brain.<br> It is funnier that man exceeds the speed of light than machine start writing on a net.<br> It can be said that this is final ultimatum from the people who can think.</div></footer></div>
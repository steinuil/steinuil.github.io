<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1,viewport-fit=cover" name=viewport><title>Building smaller Docker images faster</title><meta content="steen's online burrow" name=description><meta content=Zola name=generator><meta content=strict-origin name=referrer><link href=https://sgt.hootr.club/assets/style.css rel=stylesheet><link title="RSS feed" href=/rss.xml rel=alternate type=application/rss+xml><link title="Atom feed" href=/atom.xml rel=alternate type=application/atom+xml><link href=/assets/icon/favicon-152.png rel=apple-touch-icon-precomposed><body class=main-parent><div class=main-parent><header class=main><h1 class=header-title><a href=https://sgt.hootr.club>STEENSBURROW</a></h1><nav><ul class=unstyled><li><a class=unstyled href=https://sgt.hootr.club/me/>me</a><li><a class=unstyled href=https://sgt.hootr.club/blog/>posts</a><li><a class=unstyled href=/rss.xml>rss</a><li><a class=unstyled href=https://sgt.hootr.club/meta/>meta</a></ul></nav></header><main class=main><article><header><h1 class=title>Building smaller Docker images faster</h1><p class=subtitle>Published by <a href=/><i>steen</i></a> on <time datetime=2025-12-12>2025-12-12</time> tagged <a class=tag href=https://sgt.hootr.club/tags/docker/>#docker</a></header><div class=content><p>I've been tasked (more or less) with building the first Go service at <code>$DAYJOB</code>, which is almost exclusively a Python shop. Why Go of all languages? Well, some of my coworkers are big fans of the gopher, it's an easy language, it's attached to one of the big companies, and it's much faster than Python, so I feel more comfortable pushing for this rather than Rust or (sadly) Nix.<p>The project that recently fell onto my lap is basically RCE-as-a-service, and it just so happens that <a rel="nofollow noreferrer external" class=external-link href=https://starlark-lang.org/>one of the few languages</a> that I would feel comfortable letting users execute remotely on our servers has <a rel="nofollow noreferrer external" class=external-link href=https://github.com/google/starlark-go>a Go implementation</a>, which is as good an excuse as any to take a break from the usual snekslop.<p>I still haven't convinced anybody here to get on the Nix train, so after a short stint of building the project and the OCI images with a recursive cycle of Make and Nix, I breathed a heavy sigh and dropped it for Docker and Docker Compose, which is what we generally use here.<aside class=note><p>And just between you and me, I don't think we use them very well. CI is painfully slow and we all just kinda live with it because figuring out how the damn <code>Dockerfile</code> works sucks even more.</aside><p>Which is a shame, because Nix is pretty good at building OCI images. This is all the code you need to create a minimal image that contains only your service and nothing else, not even <code>/bin/sh</code>.<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=nix><span class=giallo-l><span style=color:#eceff4>{</span><span> pkgs</span><span style=color:#81a1c1> ?</span><span style=color:#88c0d0> import</span><span style=color:#a3be8c> &lt;nixpkgs></span><span style=color:#eceff4> {} }:</span></span>
<span class=giallo-l><span>pkgs</span><span style=color:#81a1c1>.</span><span>dockerTools</span><span style=color:#81a1c1>.</span><span>streamLayeredImage</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#8fbcbb>  name</span><span style=color:#81a1c1> =</span><span style=color:#eceff4> "</span><span style=color:#a3be8c>someimage</span><span style=color:#eceff4>"</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#8fbcbb>  tag</span><span style=color:#81a1c1> =</span><span style=color:#eceff4> "</span><span style=color:#a3be8c>latest</span><span style=color:#eceff4>"</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#8fbcbb>  config</span><span>.</span><span style=color:#8fbcbb>Cmd</span><span style=color:#81a1c1> =</span><span style=color:#eceff4> [</span></span>
<span class=giallo-l><span style=color:#eceff4>    "</span><span style=color:#81a1c1>${</span><span>pkgs</span><span style=color:#81a1c1>.</span><span>hello</span><span style=color:#81a1c1>}</span><span style=color:#a3be8c>/bin/hello</span><span style=color:#eceff4>"</span></span>
<span class=giallo-l><span style=color:#eceff4>  ]</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p>You can build that with <code>nix-build docker-test.nix</code> and inside <code>./result</code> you'll find a script that generates the image's tarball. Load it up with <code>./result | docker load</code> and Docker will report a new image called <code>someimage:latest</code> when you run <code>docker image ls</code>. It's only 45.8MB, and most of that is taken up by glibc.<p>But what if I told you that you can get more or less the same result with a simple <code>Dockerfile</code> if you know what you're doing? Especially if you're building a static executable, which Go famously does (at least when you set <code>CGO_ENABLED=0</code>) and if you're willing to sacrifice a few affordances. Who needs coreutils anyway?<p>In this post I'll show you a few tricks I found while striving to make small and fast-building images. I'm not an expert in Docker by any stretch so maybe you know all of this stuff already, but perhaps you might learn something new.<h2 id=a-barebones-image>A barebones image</h2><p>I'm using <a rel="nofollow noreferrer external" class=external-link href=https://github.com/pressly/goose><code>goose</code></a> for database migrations. I configured the <code>docker-compose.yml</code> to run its container just after the database has started and before the actual service runs, and since it's a very small self-contained tool I figured I could try to make the image as small and quick to build as possible. Let me show you the relevant part of the <code>docker-compose.yml</code> first:<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=yaml><span class=giallo-l><span style=color:#8fbcbb>services</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#8fbcbb>  migrate</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#8fbcbb>    image</span><span style=color:#eceff4>:</span><span style=color:#a3be8c> migrate:latest</span></span>
<span class=giallo-l><span style=color:#8fbcbb>    pull_policy</span><span style=color:#eceff4>:</span><span style=color:#a3be8c> build</span></span>
<span class=giallo-l><span style=color:#8fbcbb>    build</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#8fbcbb>      context</span><span style=color:#eceff4>:</span><span style=color:#a3be8c> https://github.com/pressly/goose.git#v3.26.0</span></span>
<span class=giallo-l><span style=color:#8fbcbb>      dockerfile</span><span style=color:#eceff4>:</span><span style=color:#a3be8c> $PWD/Dockerfile.migrate</span></span>
<span class=giallo-l><span style=color:#8fbcbb>    environment</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#8fbcbb>      GOOSE_DBSTRING</span><span style=color:#eceff4>:</span><span style=color:#a3be8c> postgresql://AzureDiamond:hunter2@db:5432/bobby</span></span>
<span class=giallo-l><span style=color:#8fbcbb>      GOOSE_MIGRATION_DIR</span><span style=color:#eceff4>:</span><span style=color:#a3be8c> /migrations</span></span>
<span class=giallo-l><span style=color:#8fbcbb>      GOOSE_DRIVER</span><span style=color:#eceff4>:</span><span style=color:#a3be8c> postgres</span></span>
<span class=giallo-l><span style=color:#8fbcbb>    depends_on</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#8fbcbb>      db</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#8fbcbb>        condition</span><span style=color:#eceff4>:</span><span style=color:#a3be8c> service_started</span></span>
<span class=giallo-l><span style=color:#8fbcbb>    volumes</span><span style=color:#eceff4>:</span></span>
<span class=giallo-l><span style=color:#eceff4>      -</span><span style=color:#a3be8c> ./migrations:/migrations</span></span></code></pre><p><a rel="nofollow noreferrer external" class=external-link href=https://docs.docker.com/build/concepts/context/>The <code>build.context</code> parameter</a> specifies the "set of files" that are available from the host while building a Docker image. It's the parameter that you pass after <code>docker build</code>, generally <code>.</code> (the PWD). Here I specified a GitHub URL with a tag, so when I'm referring to <code>.</code> in the <code>Dockerfile</code> above I get the root of the <code>goose</code> project on that tag's commit. I didn't know Docker could do that!<p>The <code>build.dockerfile</code> path includes <code>$PWD</code> because even if Docker itself can refer to Dockerfiles outside of its context, <a rel="nofollow noreferrer external" class=external-link href=https://github.com/docker/compose/issues/4926>Docker Compose apparently can't</a> unless you specify it as an absolute path. I think this will break if you try to run <code>docker compose</code> from another directory, but it's good enough for now.<p>Now let's take a look at the <code>Dockerfile</code> itself:<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=docker><span class=giallo-l><span style=color:#81a1c1>FROM</span><span> golang:1.25-alpine3.23 </span><span style=color:#81a1c1>AS</span><span> builder</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>WORKDIR</span><span> /build</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>ARG</span><span> CGO_ENABLED=0</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>ARG</span><span> GOCACHE=/root/.cache/go-build</span></span>
<span class=giallo-l><span style=color:#81a1c1>ARG</span><span> GOMODCACHE=/root/.cache/go-mod</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>RUN</span><span> --mount=type=cache,target=/root/.cache/go-build \</span></span>
<span class=giallo-l><span>  --mount=type=cache,target=/root/.cache/go-mod \</span></span>
<span class=giallo-l><span>  --mount=type=bind,source=.,target=/build \</span></span>
<span class=giallo-l><span>  go build -tags=</span><span style=color:#a3be8c>'no_clickhouse no_libsql no_sqlite3 no_mssql no_vertica no_mysql no_ydb'</span><span> -o /goose ./cmd/goose</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>FROM</span><span> scratch</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>COPY</span><span> --from=builder /goose /goose</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>CMD</span><span> [</span><span style=color:#a3be8c>"/goose"</span><span>, </span><span style=color:#a3be8c>"up"</span><span>]</span></span></code></pre><p>A few things to note:<ul><li>I used the Alpine image for Go because it's the smallest and it includes everything I need to build the tool.<li>I set <code>CGO_ENABLED=0</code> to ensure that the executable only builds with the Go toolchain and does not link to libc. According to <a rel="nofollow noreferrer external" class=external-link href=https://pkg.go.dev/cmd/cgo>the docs</a>, <em>The cgo tool is enabled by default for native builds on systems where it is expected to work</em> so you have to take extra care to disable it if you don't want or need it.<li>I set <code>GOCACHE</code> and <code>GOMODCACHE</code> (<a rel="nofollow noreferrer external" class=external-link href=https://pkg.go.dev/cmd/go#hdr-Environment_variables>docs</a>) to a known location to ensure that I can take advantage of <a rel="nofollow noreferrer external" class=external-link href=https://docs.docker.com/build/cache/optimize/#use-cache-mounts>cache mounts</a> on subsequent rebuilds. Admittedly this is not very useful for an external tool that I'm only expecting to build once but hey, every little bit helps.<li>Instead of <code>ADD</code>ing or <code>COPY</code>ing the package's source I <a rel="nofollow noreferrer external" class=external-link href=https://docs.docker.com/build/cache/optimize/#use-bind-mounts>bind mounted</a> it to the workdir. This should make it a bit faster because it avoids an extra copy into the build container.<li><code>FROM scratch</code> defines a <a rel="nofollow noreferrer external" class=external-link href=https://docs.docker.com/build/building/multi-stage/>second build stage</a> that ensures any artifacts from the actual build are discarded. <a rel="nofollow noreferrer external" class=external-link href=https://hub.docker.com/_/scratch/><code>scratch</code></a> is the null image.</ul><p>The result is an image with one layer containing one file that builds, loads and boots extremely fast and is only <small><em>*chef's kiss*</em></small> 15.9MB in size. Not too bad!<p><img alt="Screenshot of dive showing the resulting image" src=https://sgt.hootr.club/blog/docker-protips/smol-image.png><h2 id=the-build-context>The build context</h2><p>Earlier I mentioned the build context. <a rel="nofollow noreferrer external" class=external-link href=https://docs.docker.com/build/cache/optimize/#keep-the-context-small>Keeping it small</a> is important because <a rel="nofollow noreferrer external" class=external-link href=https://docs.docker.com/build/concepts/context/#dockerignore-files>Docker copies all files available in the build context to the builder</a> every time you run a <code>docker build</code>, so if you have lots of files in your repo that you don't need to build the image you'll probably want to exclude them. The way you do that is by keeping a <code>.dockerignore</code> file alongside your <code>Dockerfile</code>.<p>I have to stress one point: the build context includes <strong>everything</strong> inside the directory you run <code>docker build</code> from unless it's listed in <code>.dockerignore</code>. I thought some obvious things like <code>.git</code> would be excluded by default, but a quick test disproved that:<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=docker><span class=giallo-l><span style=color:#81a1c1>FROM</span><span> busybox</span></span>
<span class=giallo-l><span style=color:#81a1c1>WORKDIR</span><span> /</span></span>
<span class=giallo-l><span style=color:#81a1c1>COPY</span><span> . ./</span></span>
<span class=giallo-l><span style=color:#81a1c1>CMD</span><span> []</span></span></code></pre><p>Try saving that file as <code>Dockerfile.test</code> in one of your repos, build it with <code>docker build -f Dockerfile.text -t build-context .</code>, open a shell with <code>docker run --rm -it build-context /bin/sh</code> and run <code>find</code>. Everything's in there: <code>.git</code>, <code>.jj</code>, the <code>Dockerfile.test</code> itself, and all the rest of the build artifacts and assorted junk you have accumulated in your project directory. Ignoring them won't make your images smaller, but it might make the build quicker.<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span># .dockerignore</span></span>
<span class=giallo-l><span>.*</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>Dockerfile*</span></span>
<span class=giallo-l><span>docker-compose.yml</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span># ...</span></span></code></pre><h2 id=granular-layers>Granular layers</h2><p><a rel="nofollow noreferrer external" class=external-link href=https://docs.docker.com/build/cache/optimize/#order-your-layers>Splitting and ordering layers</a> is probably the most well-known and obvious Docker build time optimization there is, but it doesn't hurt to mention. This is the <code>Dockerfile</code> for the service I'm building:<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=docker><span class=giallo-l><span style=color:#81a1c1>FROM</span><span> golang:1.25-alpine3.23 </span><span style=color:#81a1c1>AS</span><span> builder</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>WORKDIR</span><span> /build</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>ARG</span><span> CGO_ENABLED=0</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>ARG</span><span> GOCACHE=/root/.cache/go-build</span></span>
<span class=giallo-l><span style=color:#81a1c1>ARG</span><span> GOMODCACHE=/root/.cache/go-mod</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>RUN</span><span> --mount=type=cache,target=/root/.cache/go-build \</span></span>
<span class=giallo-l><span>  --mount=type=cache,target=/root/.cache/go-mod \</span></span>
<span class=giallo-l><span>  go install github.com/DataDog/orchestrion@latest</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>RUN</span><span> --mount=type=bind,source=go.mod,target=go.mod \</span></span>
<span class=giallo-l><span>  --mount=type=bind,source=go.sum,target=go.sum \</span></span>
<span class=giallo-l><span>  --mount=type=cache,target=/root/.cache/go-build \</span></span>
<span class=giallo-l><span>  --mount=type=cache,target=/root/.cache/go-mod \</span></span>
<span class=giallo-l><span>  go mod download</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>RUN</span><span> --mount=type=bind,source=go.mod,target=go.mod \</span></span>
<span class=giallo-l><span>  --mount=type=bind,source=go.sum,target=go.sum \</span></span>
<span class=giallo-l><span>  --mount=type=cache,target=/root/.cache/go-build \</span></span>
<span class=giallo-l><span>  --mount=type=cache,target=/root/.cache/go-mod \</span></span>
<span class=giallo-l><span>  --mount=type=bind,source=internal,target=internal \</span></span>
<span class=giallo-l><span>  --mount=type=bind,source=cmd,target=cmd \</span></span>
<span class=giallo-l><span>  --mount=type=bind,source=orchestrion.tool.go,target=orchestrion.tool.go \</span></span>
<span class=giallo-l><span>  orchestrion go build -o server ./cmd/server</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>FROM</span><span> alpine:3.23 </span><span style=color:#81a1c1>AS</span><span> prod</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>WORKDIR</span><span> /app</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>COPY</span><span> --from=builder /build/server .</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>ENTRYPOINT</span><span> [</span><span style=color:#a3be8c>"/app/server"</span><span>]</span></span></code></pre><p>You can see all the bind and cache mount tricks from earlier, not much has changed. I'm installing <a rel="nofollow noreferrer external" class=external-link href=https://github.com/DataDog/orchestrion><code>orchestrion</code></a> (a great tool to bloat up your binary size if you ever feel like it) early because that's the least likely to change. After that I bind mount <code>go.mod</code> and <code>go.sum</code> and only download the dependencies, because that's the step that generally takes the most time and dependencies change less often than code. Only at the end do I bind mount the package directories and build the server.<aside class=note><p>I opted for good ol' Alpine for the base final image. It only adds a couple more MBs and I'm sure whoever will eventually have to shell into a prod container will appreciate having something to work with.</aside><p>You can iterate on this by changing one of the relevant files and ensuring that all the previous steps are marked as <code>CACHED</code> on the next <code>docker build</code>. Again, this won't save you space but it'll save you a lot of time while iterating.<h2 id=conclusions>Conclusions</h2><p>Summing up:<ul><li>Read the <a rel="nofollow noreferrer external" class=external-link href=https://docs.docker.com/build/cache/optimize/>Optimize cache usage in builds</a> page in the Docker documentation, and maybe take a look at the rest while you're there.<li>Split, merge and order layers according to how often you expect them to be rebuilt. Directives like <code>ENV</code>, <code>ARG</code> and <code>WORKDIR</code> should go before everything else.<li>Use <a rel="nofollow noreferrer external" class=external-link href=https://docs.docker.com/build/building/multi-stage/>multi-stage builds</a> to shrink the final image size. Consider if you can get away with using <code>scratch</code>, <code>busybox</code> or <code>alpine</code> for the final image.<li>If your project contains multiple separate applications (for example a backend and a frontend) you can create separate build stages for each of them, and then copy the results into a final image. Stages that don't depend on each other <a rel="nofollow noreferrer external" class=external-link href=https://docs.docker.com/build/buildkit/>are built in parallel if you're using BuildKit</a>, and you can do <a rel="nofollow noreferrer external" class=external-link href=https://medium.com/@tonistiigi/advanced-multi-stage-build-patterns-6f741b852fae>all sorts of tricks</a> with multi-stage builds to ensure your CPU runs hot all the time.<li>Add a <code>.dockerignore</code> to your project, and make sure to put <code>.git</code> in there if you don't need it.<li>Try to set up cache mounts to make sure dependencies and intermediate build artifacts are persisted across builds. Some CI services (GitHub actions, apparently) even let you set up <a rel="nofollow noreferrer external" class=external-link href=https://docs.docker.com/build/cache/optimize/#use-an-external-cache>external caches</a>.<li>Try to use bind mounts instead of <code>COPY</code>ing source files into the builder. Bind mounts are usually read-only, but you can make them read-write if you really need to.<li>I didn't use it in my <code>Dockerfile</code>s, but apparently you should be using <code>ADD</code> for downloading files, archives or Git repos during your build. <a rel="nofollow noreferrer external" class=external-link href=https://docs.docker.com/build/building/best-practices/#add-or-copy>The docs</a> mention that <code>COPY</code> should mostly be used for copying files between stages or for files you need in your final image, and for the rest you should try to use bind mounts.<li>Use smaller base images when possible and if you <em>really</em> have to install stuff with <code>apt</code> you should make an intermediate image and upload it to your container repository of choice so your poor runners don't have to hammer Debian's mirrors every single time you push.</ul><p>One last trick before the post is over: I just discovered that Docker Compose <a rel="nofollow noreferrer external" class=external-link href=https://docs.docker.com/compose/how-tos/file-watch/>has a watch mode</a> that tracks changes in the build context and rebuilds (or does other things with) your image on every change. Nice!</div></article></main><footer class=main><a class=logo href=/> <svg viewbox="0 0 79 49" version=1.1 xmlns=http://www.w3.org/2000/svg xmlns:svg=http://www.w3.org/2000/svg><title>Steen's online burrow</title><g fill=currentColor><g><path d="M 17,7 V 9 H 15 V 8 h -1 v 3 h 1 v 1 h 2 v 1 h 4 V 9 H 20 V 8 H 19 V 5 h 1 V 4 h 1 V 3 h 4 v 1 h -3 v 3 h 1 v 1 h 1 v 4 h -1 v 1 h -1 c 0,0 0,1 0,1 H 16 V 13 H 13 V 12 10 H 12 V 8 h 1 V 7 Z"/><path d="m 30,5 v 1 h 2 V 5 h 3 v 1 h -2 v 1 h -2 v 4 h -1 v 1 h -1 v 1 h -1 c 0,0 0,2 0,2 h -1 c 0,0 0,1 0,1 h -1 v -3 h 1 v -2 h 1 V 7 H 26 V 6 H 24 V 5 Z"/><path d="m 39,5 v 2 h -1 c 0,0 0,1 0,1 h -1 c 0,0 0,1 0,1 h -2 v 1 h 4 c 0,0 0,2 0,2 h -2 v -1 h -3 v 1 h -1 v 2 h 2 v -1 h 3 v 1 h 1 v 1 h 1 c 0,0 0,1 0,1 h -2 v -1 h -4 c 0,0 0,1 0,1 h -4 v -1 h 1 v -2 h 1 v -2 h 1 V 8 h 3 V 7 h 1 V 6 h 1 V 5 Z"/><path d="m 42,5 v 1 h 1 v 1 h 1 v 1 h 1 v 1 h 2 v 1 H 44 V 9 h -1 v 2 h 3 v 1 h -2 v 1 h -1 v 1 h 2 v -1 h 2 v 2 h -4 c 0,0 0,1 0,1 h -2 v -2 h 1 V 9 H 41 V 7 H 40 V 5 Z"/><path d="m 48,6 v 2 h 1 v 4 h 1 c 0,0 0,2 0,2 h -1 v 3 c 0,0 1,0 1,0 v -1 h 1 v -2 h 1 v -2 h 1 v 1 h 1 v 1 h 1 v 1 h 2 V 14 H 56 V 9 h 1 V 7 h 1 V 5 h 1 V 4 h 1 V 2 h -1 v 1 h -2 v 1 h -1 v 4 h -1 v 4 H 54 V 11 H 53 V 10 H 51 V 8 H 50 V 7 H 49 V 6 Z"/><path d="m 61,0 v 1 h 1 v 3 h 2 V 2 H 63 V 0 Z"/><path d="m 67,4 v 1 h -1 v 2 h 1 c 0,0 0,3 0,3 h -1 v 1 c 0,0 -4,0 -4,0 v -1 h 2 V 9 h 1 V 8 H 64 V 5 h 1 V 4 Z"/></g><g><path d="m 26,22 h 3 v -1 h -3 z"/><path d="m 31,20 v 1 h 1 v 1 h 1 v -2 z m 1,2 h -1 v -1 h -1 v 2 h 2 z"/><path d="m 34,20 v 3 h 1 v -2 h 1 v 2 h 1 v -2 h -1 v -1 z"/><path d="m 38,19 v 4 h 1 v -4 z"/><path d="m 40,19 v 1 h 1 v -1 z"/><path d="m 40,21 v 2 h 1 v -2 z"/><path d="m 42,23 v -3 h 2 v 1 h 1 c 0,0 0,2 0,2 h -1 v -2 h -1 v 2 z"/><path d="m 46,21 v 2 h 1 v 1 h 1 v -1 h -1 v -2 h 1 v 1 h 1 v -2 h -2 v 1 z"/><path d="m 50,21 c 0,0 0,1 0,1 h 3 v -1 z"/></g><g><path d="m 5,26 v 1 H 4 v 6 H 3 v 7 H 2 v 4 H 1 v 2 H 0 v 3 h 6 v -1 h 2 v -1 h 2 v -1 h 2 v -1 h 2 v -4 h -1 v -1 h -1 v -2 h 1 v -2 h 1 v -1 h 1 v -1 h 1 V 28 H 12 V 27 H 9 v -1 z m 2,4 h 2 v 1 h 3 v 2 h -1 v 1 h -1 v 1 H 9 v 1 H 8 v 1 H 6 V 36 H 7 Z M 6,41 h 2 v 1 h 2 v 1 H 8 v 1 H 6 v 1 H 5 v -2 h 1 z"/><path d="m 17,26 v 3 h 1 v 2 h -1 v 5 h -1 v 4 h -1 v 4 h 1 v 2 h 9 v -1 h 1 v -3 h 1 V 25 h -4 v 5 h 1 v 9 h -1 v 3 h -1 v 1 h -3 v -4 h 1 v -5 h 1 v -8 z"/><path d="m 28,27 v 5 h 1 v 2 h -1 v 14 h 3 V 38 h 1 v 4 h 1 v 4 h 1 v 2 h 3 v -5 h -1 v -4 h -1 v -5 h 3 v -6 h -2 v -1 z m 4,3 h 1 v 1 h -1 z"/><path d="m 40,27 v 21 h 3 V 37 h 1 v 1 h 1 v 1 h 1 v 1 h 1 v 2 h 1 v 1 h 1 v 2 h 4 v -3 h -1 v -1 h -1 v -2 h -1 v -1 h -1 v -1 h -1 v -9 h -2 v -1 z m 3,4 h 2 v 1 h -1 v 1 h -1 z"/><path d="m 52,27 v 1 h -1 v 1 h -1 v 7 h 1 v 1 h 1 v 1 h 1 v 1 h 5 v -1 h 2 v -1 h 1 v -8 h -1 v -1 h -4 v -1 z m 2,4 h 3 v 1 h 1 v 2 h -1 v 1 h -2 v -1 h -1 v -1 h -1 v -1 h 1 z"/><path d="m 63,25 v 4 h 1 v 16 h 4 v -1 h 1 v -1 h 1 v -2 h 2 v 1 h 2 v 1 h 1 v 1 h 4 v -5 h -1 v -3 h -1 v -2 h -1 v -2 h -1 v -2 h -1 v -2 h -1 v -3 h -1 v -1 h -3 v 4 h 1 v 3 h 1 v 2 h 1 v 2 h 1 v 2 h 1 v 1 h -1 v -1 h -4 v 1 H 67 V 26 h -1 v -1 z"/></g></g></svg> </a><div class=blurb>There is no end though there is a start in the past — Infinity.<br> It speaks, it ruins, and it goes though it consumes the soul — Finite.<br> Only the person who has wisdom can read the most foolish one from the history.<br> The daemon that lives in the machine doesn't understand the daemon that lives in the brain.<br> It is funnier that man exceeds the speed of light than machine start writing on a net.<br> It can be said that this is final ultimatum from the people who can think.</div></footer></div>